<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>GE_MobileMap&#x2F;www&#x2F;lib&#x2F;MM_JSSyncEngine&#x2F;MM_JSSyncEngine.js - MM Sync Engine</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;mm-proth.s3.amazonaws.com&#x2F;ge_mobileMap&#x2F;icon&#x2F;icon-72.png" title="MM Sync Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ForcetkClient.html">ForcetkClient</a></li>
            
                <li><a href="..&#x2F;classes/MMJSE_SmartStoreUtil.html">MMJSE_SmartStoreUtil</a></li>
            
                <li><a href="..&#x2F;classes/MMSync.html">MMSync</a></li>
            
                <li><a href="..&#x2F;classes/Network.html">Network</a></li>
            
                <li><a href="..&#x2F;classes/OfflineQueue.html">OfflineQueue</a></li>
            
                <li><a href="..&#x2F;classes/sforce.html">sforce</a></li>
            
                <li><a href="..&#x2F;classes/sforce.Base64Binary.html">sforce.Base64Binary</a></li>
            
                <li><a href="..&#x2F;classes/sforce.Connection.html">sforce.Connection</a></li>
            
                <li><a href="..&#x2F;classes/sforce.internal.html">sforce.internal</a></li>
            
                <li><a href="..&#x2F;classes/sforce.LeadConvert.html">sforce.LeadConvert</a></li>
            
                <li><a href="..&#x2F;classes/sforce.MergeRequest.html">sforce.MergeRequest</a></li>
            
                <li><a href="..&#x2F;classes/sforce.SoapTransport.html">sforce.SoapTransport</a></li>
            
                <li><a href="..&#x2F;classes/sforce.SObject.html">sforce.SObject</a></li>
            
                <li><a href="..&#x2F;classes/sforce.StringBuffer.html">sforce.StringBuffer</a></li>
            
                <li><a href="..&#x2F;classes/sforce.Xml.html">sforce.Xml</a></li>
            
                <li><a href="..&#x2F;classes/sforce.XmlReader.html">sforce.XmlReader</a></li>
            
                <li><a href="..&#x2F;classes/sforce.XmlWriter.html">sforce.XmlWriter</a></li>
            
                <li><a href="..&#x2F;classes/SObject.html">SObject</a></li>
            
                <li><a href="..&#x2F;classes/Util.html">Util</a></li>
            
                <li><a href="..&#x2F;classes/vo.MetadataVO.html">vo.MetadataVO</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Forcetk.html">Forcetk</a></li>
            
                <li><a href="..&#x2F;modules/MM_JSSyncEngine.html">MM_JSSyncEngine</a></li>
            
                <li><a href="..&#x2F;modules/SalesforceAjaxToolkit.html">SalesforceAjaxToolkit</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: GE_MobileMap&#x2F;www&#x2F;lib&#x2F;MM_JSSyncEngine&#x2F;MM_JSSyncEngine.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * MM JSync library
 * version 1.0.0a
 **&#x2F;


&#x2F;&#x2F;     Underscore.js 1.4.2
&#x2F;&#x2F;     http:&#x2F;&#x2F;underscorejs.org
&#x2F;&#x2F;     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
&#x2F;&#x2F;     Underscore may be freely distributed under the MIT license.

(function() {

  &#x2F;&#x2F; Baseline setup
  &#x2F;&#x2F; --------------

  &#x2F;&#x2F; Establish the root object, &#x60;window&#x60; in the browser, or &#x60;global&#x60; on the server.
  var root = this;

  &#x2F;&#x2F; Save the previous value of the &#x60;_&#x60; variable.
  var previousUnderscore = root._;

  &#x2F;&#x2F; Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  &#x2F;&#x2F; Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  &#x2F;&#x2F; Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  &#x2F;&#x2F; All **ECMAScript 5** native function implementations that we hope to use
  &#x2F;&#x2F; are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  &#x2F;&#x2F; Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  &#x2F;&#x2F; Export the Underscore object for **Node.js**, with
  &#x2F;&#x2F; backwards-compatibility for the old &#x60;require()&#x60; API. If we&#x27;re in
  &#x2F;&#x2F; the browser, add &#x60;_&#x60; as a global object via a string identifier,
  &#x2F;&#x2F; for Closure Compiler &quot;advanced&quot; mode.
  if (typeof exports !== &#x27;undefined&#x27;) {
    if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root[&#x27;_&#x27;] = _;
  }

  &#x2F;&#x2F; Current version.
  _.VERSION = &#x27;1.4.2&#x27;;

  &#x2F;&#x2F; Collection Functions
  &#x2F;&#x2F; --------------------

  &#x2F;&#x2F; The cornerstone, an &#x60;each&#x60; implementation, aka &#x60;forEach&#x60;.
  &#x2F;&#x2F; Handles objects with the built-in &#x60;forEach&#x60;, arrays, and raw objects.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;forEach&#x60; if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach &amp;&amp; obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i &lt; l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  &#x2F;&#x2F; Return the results of applying the iterator to each element.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;map&#x60; if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap &amp;&amp; obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  &#x2F;&#x2F; **Reduce** builds up a single result from a list of values, aka &#x60;inject&#x60;,
  &#x2F;&#x2F; or &#x60;foldl&#x60;. Delegates to **ECMAScript 5**&#x27;s native &#x60;reduce&#x60; if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length &gt; 2;
    if (obj == null) obj = [];
    if (nativeReduce &amp;&amp; obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(&#x27;Reduce of empty array with no initial value&#x27;);
    return memo;
  };

  &#x2F;&#x2F; The right-associative version of reduce, also known as &#x60;foldr&#x60;.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;reduceRight&#x60; if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length &gt; 2;
    if (obj == null) obj = [];
    if (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return arguments.length &gt; 2 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(&#x27;Reduce of empty array with no initial value&#x27;);
    return memo;
  };

  &#x2F;&#x2F; Return the first value which passes a truth test. Aliased as &#x60;detect&#x60;.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  &#x2F;&#x2F; Return all the elements that pass a truth test.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;filter&#x60; if available.
  &#x2F;&#x2F; Aliased as &#x60;select&#x60;.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter &amp;&amp; obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  &#x2F;&#x2F; Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  &#x2F;&#x2F; Determine whether all of the elements match a truth test.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;every&#x60; if available.
  &#x2F;&#x2F; Aliased as &#x60;all&#x60;.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery &amp;&amp; obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result &amp;&amp; iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  &#x2F;&#x2F; Determine if at least one element in the object matches a truth test.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;some&#x60; if available.
  &#x2F;&#x2F; Aliased as &#x60;any&#x60;.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome &amp;&amp; obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  &#x2F;&#x2F; Determine if the array or object contains a given value (using &#x60;===&#x60;).
  &#x2F;&#x2F; Aliased as &#x60;include&#x60;.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  &#x2F;&#x2F; Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  &#x2F;&#x2F; Convenience version of a common use case of &#x60;map&#x60;: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  &#x2F;&#x2F; Convenience version of a common use case of &#x60;filter&#x60;: selecting only objects
  &#x2F;&#x2F; with specific &#x60;key:value&#x60; pairs.
  _.where = function(obj, attrs) {
    if (_.isEmpty(attrs)) return [];
    return _.filter(obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  &#x2F;&#x2F; Return the maximum element or (element-based computation).
  &#x2F;&#x2F; Can&#x27;t optimize arrays of integers longer than 65,535 elements.
  &#x2F;&#x2F; See: https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0] &amp;&amp; obj.length &lt; 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator &amp;&amp; _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed &gt;= result.computed &amp;&amp; (result = {value : value, computed : computed});
    });
    return result.value;
  };

  &#x2F;&#x2F; Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[0] === +obj[0] &amp;&amp; obj.length &lt; 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator &amp;&amp; _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed &lt; result.computed &amp;&amp; (result = {value : value, computed : computed});
    });
    return result.value;
  };

  &#x2F;&#x2F; Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  &#x2F;&#x2F; An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  &#x2F;&#x2F; Sort the object&#x27;s values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a &gt; b || a === void 0) return 1;
        if (a &lt; b || b === void 0) return -1;
      }
      return left.index &lt; right.index ? -1 : 1;
    }), &#x27;value&#x27;);
  };

  &#x2F;&#x2F; An internal function used for aggregate &quot;group by&quot; operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  &#x2F;&#x2F; Groups the object&#x27;s values by a criterion. Pass either a string attribute
  &#x2F;&#x2F; to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  &#x2F;&#x2F; Counts instances of an object that group by a certain criterion. Pass
  &#x2F;&#x2F; either a string attribute to count by, or a function that returns the
  &#x2F;&#x2F; criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  &#x2F;&#x2F; Use a comparator function to figure out the smallest index at which
  &#x2F;&#x2F; an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low &lt; high) {
      var mid = (low + high) &gt;&gt;&gt; 1;
      iterator.call(context, array[mid]) &lt; value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  &#x2F;&#x2F; Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (obj.length === +obj.length) return slice.call(obj);
    return _.values(obj);
  };

  &#x2F;&#x2F; Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  &#x2F;&#x2F; Array Functions
  &#x2F;&#x2F; ---------------

  &#x2F;&#x2F; Get the first element of an array. Passing **n** will return the first N
  &#x2F;&#x2F; values in the array. Aliased as &#x60;head&#x60; and &#x60;take&#x60;. The **guard** check
  &#x2F;&#x2F; allows it to work with &#x60;_.map&#x60;.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) &amp;&amp; !guard ? slice.call(array, 0, n) : array[0];
  };

  &#x2F;&#x2F; Returns everything but the last entry of the array. Especially useful on
  &#x2F;&#x2F; the arguments object. Passing **n** will return all the values in
  &#x2F;&#x2F; the array, excluding the last N. The **guard** check allows it to work with
  &#x2F;&#x2F; &#x60;_.map&#x60;.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  &#x2F;&#x2F; Get the last element of an array. Passing **n** will return the last N
  &#x2F;&#x2F; values in the array. The **guard** check allows it to work with &#x60;_.map&#x60;.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) &amp;&amp; !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  &#x2F;&#x2F; Returns everything but the first entry of the array. Aliased as &#x60;tail&#x60; and &#x60;drop&#x60;.
  &#x2F;&#x2F; Especially useful on the arguments object. Passing an **n** will return
  &#x2F;&#x2F; the rest N values in the array. The **guard**
  &#x2F;&#x2F; check allows it to work with &#x60;_.map&#x60;.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  &#x2F;&#x2F; Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  &#x2F;&#x2F; Internal implementation of a recursive &#x60;flatten&#x60; function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  &#x2F;&#x2F; Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  &#x2F;&#x2F; Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  &#x2F;&#x2F; Produce a duplicate-free version of the array. If the array has already
  &#x2F;&#x2F; been sorted, you have the option of using a faster algorithm.
  &#x2F;&#x2F; Aliased as &#x60;unique&#x60;.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  &#x2F;&#x2F; Produce an array that contains the union: each distinct element from all of
  &#x2F;&#x2F; the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  &#x2F;&#x2F; Produce an array that contains every item shared between all the
  &#x2F;&#x2F; passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) &gt;= 0;
      });
    });
  };

  &#x2F;&#x2F; Take the difference between one array and a number of other arrays.
  &#x2F;&#x2F; Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  &#x2F;&#x2F; Zip together multiple lists into a single array -- elements that share
  &#x2F;&#x2F; an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, &#x27;length&#x27;));
    var results = new Array(length);
    for (var i = 0; i &lt; length; i++) {
      results[i] = _.pluck(args, &quot;&quot; + i);
    }
    return results;
  };

  &#x2F;&#x2F; Converts lists into objects. Pass either a single array of &#x60;[key, value]&#x60;
  &#x2F;&#x2F; pairs, or two parallel arrays of the same length -- one of keys, and one of
  &#x2F;&#x2F; the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i &lt; l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  &#x2F;&#x2F; If the browser doesn&#x27;t supply us with indexOf (I&#x27;m looking at you, **MSIE**),
  &#x2F;&#x2F; we need this function. Return the position of the first occurrence of an
  &#x2F;&#x2F; item in an array, or -1 if the item is not included in the array.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;indexOf&#x60; if available.
  &#x2F;&#x2F; If the array is large and already in sort order, pass &#x60;true&#x60;
  &#x2F;&#x2F; for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == &#x27;number&#x27;) {
        i = (isSorted &lt; 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i &lt; l; i++) if (array[i] === item) return i;
    return -1;
  };

  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;lastIndexOf&#x60; if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  &#x2F;&#x2F; Generate an integer Array containing an arithmetic progression. A port of
  &#x2F;&#x2F; the native Python &#x60;range()&#x60; function. See
  &#x2F;&#x2F; [the Python documentation](http:&#x2F;&#x2F;docs.python.org&#x2F;library&#x2F;functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length &lt;= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) &#x2F; step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx &lt; len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  &#x2F;&#x2F; Function (ahem) Functions
  &#x2F;&#x2F; ------------------

  &#x2F;&#x2F; Reusable constructor function for prototype setting.
  var ctor = function(){};

  &#x2F;&#x2F; Create a function bound to a given object (assigning &#x60;this&#x60;, and arguments,
  &#x2F;&#x2F; optionally). Binding with arguments is also known as &#x60;curry&#x60;.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;Function.bind&#x60; if available.
  &#x2F;&#x2F; We check for &#x60;func.bind&#x60; first, to fail fast when &#x60;func&#x60; is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind &amp;&amp; nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  &#x2F;&#x2F; Bind all of an object&#x27;s methods to that object. Useful for ensuring that
  &#x2F;&#x2F; all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  &#x2F;&#x2F; Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  &#x2F;&#x2F; Delays a function for the given number of milliseconds, and then calls
  &#x2F;&#x2F; it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  &#x2F;&#x2F; Defers a function, scheduling it to run after the current call stack has
  &#x2F;&#x2F; cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  &#x2F;&#x2F; Returns a function, that, when invoked, will only be triggered at most once
  &#x2F;&#x2F; during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining &lt;= 0) {
        clearTimeout(timeout);
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  &#x2F;&#x2F; Returns a function, that, as long as it continues to be invoked, will not
  &#x2F;&#x2F; be triggered. The function will be called after it stops being called for
  &#x2F;&#x2F; N milliseconds. If &#x60;immediate&#x60; is passed, trigger the function on the
  &#x2F;&#x2F; leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate &amp;&amp; !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  &#x2F;&#x2F; Returns a function that will be executed at most one time, no matter how
  &#x2F;&#x2F; often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  &#x2F;&#x2F; Returns the first function passed as an argument to the second,
  &#x2F;&#x2F; allowing you to adjust arguments, run code before and after, and
  &#x2F;&#x2F; conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  &#x2F;&#x2F; Returns a function that is the composition of a list of functions, each
  &#x2F;&#x2F; consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i &gt;= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  &#x2F;&#x2F; Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times &lt;= 0) return func();
    return function() {
      if (--times &lt; 1) {
        return func.apply(this, arguments);
      }
    };
  };

  &#x2F;&#x2F; Object Functions
  &#x2F;&#x2F; ----------------

  &#x2F;&#x2F; Retrieve the names of an object&#x27;s properties.
  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#x27;s native &#x60;Object.keys&#x60;
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError(&#x27;Invalid object&#x27;);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  &#x2F;&#x2F; Retrieve the values of an object&#x27;s properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  &#x2F;&#x2F; Convert an object into a list of &#x60;[key, value]&#x60; pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  &#x2F;&#x2F; Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  &#x2F;&#x2F; Return a sorted list of the function names available on the object.
  &#x2F;&#x2F; Aliased as &#x60;methods&#x60;
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  &#x2F;&#x2F; Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  &#x2F;&#x2F; Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   &#x2F;&#x2F; Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  &#x2F;&#x2F; Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  &#x2F;&#x2F; Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  &#x2F;&#x2F; Invokes interceptor with the obj, and then returns obj.
  &#x2F;&#x2F; The primary purpose of this method is to &quot;tap into&quot; a method chain, in
  &#x2F;&#x2F; order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  &#x2F;&#x2F; Internal recursive comparison function for &#x60;isEqual&#x60;.
  var eq = function(a, b, aStack, bStack) {
    &#x2F;&#x2F; Identical objects are equal. &#x60;0 === -0&#x60;, but they aren&#x27;t identical.
    &#x2F;&#x2F; See the Harmony &#x60;egal&#x60; proposal: http:&#x2F;&#x2F;wiki.ecmascript.org&#x2F;doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 &#x2F; a == 1 &#x2F; b;
    &#x2F;&#x2F; A strict comparison is necessary because &#x60;null == undefined&#x60;.
    if (a == null || b == null) return a === b;
    &#x2F;&#x2F; Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    &#x2F;&#x2F; Compare &#x60;[[Class]]&#x60; names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      &#x2F;&#x2F; Strings, numbers, dates, and booleans are compared by value.
      case &#x27;[object String]&#x27;:
        &#x2F;&#x2F; Primitives and their corresponding object wrappers are equivalent; thus, &#x60;&quot;5&quot;&#x60; is
        &#x2F;&#x2F; equivalent to &#x60;new String(&quot;5&quot;)&#x60;.
        return a == String(b);
      case &#x27;[object Number]&#x27;:
        &#x2F;&#x2F; &#x60;NaN&#x60;s are equivalent, but non-reflexive. An &#x60;egal&#x60; comparison is performed for
        &#x2F;&#x2F; other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 &#x2F; a == 1 &#x2F; b : a == +b);
      case &#x27;[object Date]&#x27;:
      case &#x27;[object Boolean]&#x27;:
        &#x2F;&#x2F; Coerce dates and booleans to numeric primitive values. Dates are compared by their
        &#x2F;&#x2F; millisecond representations. Note that invalid dates with millisecond representations
        &#x2F;&#x2F; of &#x60;NaN&#x60; are not equivalent.
        return +a == +b;
      &#x2F;&#x2F; RegExps are compared by their source patterns and flags.
      case &#x27;[object RegExp]&#x27;:
        return a.source == b.source &amp;&amp;
               a.global == b.global &amp;&amp;
               a.multiline == b.multiline &amp;&amp;
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != &#x27;object&#x27; || typeof b != &#x27;object&#x27;) return false;
    &#x2F;&#x2F; Assume equality for cyclic structures. The algorithm for detecting cyclic
    &#x2F;&#x2F; structures is adapted from ES 5.1 section 15.12.3, abstract operation &#x60;JO&#x60;.
    var length = aStack.length;
    while (length--) {
      &#x2F;&#x2F; Linear search. Performance is inversely proportional to the number of
      &#x2F;&#x2F; unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    &#x2F;&#x2F; Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    &#x2F;&#x2F; Recursively compare objects and arrays.
    if (className == &#x27;[object Array]&#x27;) {
      &#x2F;&#x2F; Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        &#x2F;&#x2F; Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      &#x2F;&#x2F; Objects with different constructors are not equivalent, but &#x60;Object&#x60;s
      &#x2F;&#x2F; from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; (aCtor instanceof aCtor) &amp;&amp;
                               _.isFunction(bCtor) &amp;&amp; (bCtor instanceof bCtor))) {
        return false;
      }
      &#x2F;&#x2F; Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          &#x2F;&#x2F; Count the expected number of properties.
          size++;
          &#x2F;&#x2F; Deep compare each member.
          if (!(result = _.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      &#x2F;&#x2F; Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) &amp;&amp; !(size--)) break;
        }
        result = !size;
      }
    }
    &#x2F;&#x2F; Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  &#x2F;&#x2F; Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  &#x2F;&#x2F; Is a given array, string, or object empty?
  &#x2F;&#x2F; An &quot;empty&quot; object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  &#x2F;&#x2F; Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj &amp;&amp; obj.nodeType === 1);
  };

  &#x2F;&#x2F; Is a given value an array?
  &#x2F;&#x2F; Delegates to ECMA5&#x27;s native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == &#x27;[object Array]&#x27;;
  };

  &#x2F;&#x2F; Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  &#x2F;&#x2F; Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each([&#x27;Arguments&#x27;, &#x27;Function&#x27;, &#x27;String&#x27;, &#x27;Number&#x27;, &#x27;Date&#x27;, &#x27;RegExp&#x27;], function(name) {
    _[&#x27;is&#x27; + name] = function(obj) {
      return toString.call(obj) == &#x27;[object &#x27; + name + &#x27;]&#x27;;
    };
  });

  &#x2F;&#x2F; Define a fallback version of the method in browsers (ahem, IE), where
  &#x2F;&#x2F; there isn&#x27;t any inspectable &quot;Arguments&quot; type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj &amp;&amp; _.has(obj, &#x27;callee&#x27;));
    };
  }

  &#x2F;&#x2F; Optimize &#x60;isFunction&#x60; if appropriate.
  if (typeof (&#x2F;.&#x2F;) !== &#x27;function&#x27;) {
    _.isFunction = function(obj) {
      return typeof obj === &#x27;function&#x27;;
    };
  }

  &#x2F;&#x2F; Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite( obj ) &amp;&amp; !isNaN( parseFloat(obj) );
  };

  &#x2F;&#x2F; Is the given value &#x60;NaN&#x60;? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) &amp;&amp; obj != +obj;
  };

  &#x2F;&#x2F; Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == &#x27;[object Boolean]&#x27;;
  };

  &#x2F;&#x2F; Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  &#x2F;&#x2F; Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  &#x2F;&#x2F; Shortcut function for checking if an object has a given property directly
  &#x2F;&#x2F; on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  &#x2F;&#x2F; Utility Functions
  &#x2F;&#x2F; -----------------

  &#x2F;&#x2F; Run Underscore.js in *noConflict* mode, returning the &#x60;_&#x60; variable to its
  &#x2F;&#x2F; previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  &#x2F;&#x2F; Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  &#x2F;&#x2F; Run a function **n** times.
  _.times = function(n, iterator, context) {
    for (var i = 0; i &lt; n; i++) iterator.call(context, i);
  };

  &#x2F;&#x2F; Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + (0 | Math.random() * (max - min + 1));
  };

  &#x2F;&#x2F; List of HTML entities for escaping.
  var entityMap = {
    escape: {
      &#x27;&amp;&#x27;: &#x27;&amp;amp;&#x27;,
      &#x27;&lt;&#x27;: &#x27;&amp;lt;&#x27;,
      &#x27;&gt;&#x27;: &#x27;&amp;gt;&#x27;,
      &#x27;&quot;&#x27;: &#x27;&amp;quot;&#x27;,
      &quot;&#x27;&quot;: &#x27;&amp;#x27;&#x27;,
      &#x27;&#x2F;&#x27;: &#x27;&amp;#x2F;&#x27;
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  &#x2F;&#x2F; Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp(&#x27;[&#x27; + _.keys(entityMap.escape).join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;),
    unescape: new RegExp(&#x27;(&#x27; + _.keys(entityMap.unescape).join(&#x27;|&#x27;) + &#x27;)&#x27;, &#x27;g&#x27;)
  };

  &#x2F;&#x2F; Functions for escaping and unescaping strings to&#x2F;from HTML interpolation.
  _.each([&#x27;escape&#x27;, &#x27;unescape&#x27;], function(method) {
    _[method] = function(string) {
      if (string == null) return &#x27;&#x27;;
      return (&#x27;&#x27; + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  &#x2F;&#x2F; If the value of the named property is a function then invoke it;
  &#x2F;&#x2F; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  &#x2F;&#x2F; Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  &#x2F;&#x2F; Generate a unique integer id (unique within the entire client session).
  &#x2F;&#x2F; Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  &#x2F;&#x2F; By default, Underscore uses ERB-style template delimiters, change the
  &#x2F;&#x2F; following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : &#x2F;&lt;%([\s\S]+?)%&gt;&#x2F;g,
    interpolate : &#x2F;&lt;%=([\s\S]+?)%&gt;&#x2F;g,
    escape      : &#x2F;&lt;%-([\s\S]+?)%&gt;&#x2F;g
  };

  &#x2F;&#x2F; When customizing &#x60;templateSettings&#x60;, if you don&#x27;t want to define an
  &#x2F;&#x2F; interpolation, evaluation or escaping regex, we need one that is
  &#x2F;&#x2F; guaranteed not to match.
  var noMatch = &#x2F;(.)^&#x2F;;

  &#x2F;&#x2F; Certain characters need to be escaped so that they can be put into a
  &#x2F;&#x2F; string literal.
  var escapes = {
    &quot;&#x27;&quot;:      &quot;&#x27;&quot;,
    &#x27;\\&#x27;:     &#x27;\\&#x27;,
    &#x27;\r&#x27;:     &#x27;r&#x27;,
    &#x27;\n&#x27;:     &#x27;n&#x27;,
    &#x27;\t&#x27;:     &#x27;t&#x27;,
    &#x27;\u2028&#x27;: &#x27;u2028&#x27;,
    &#x27;\u2029&#x27;: &#x27;u2029&#x27;
  };

  var escaper = &#x2F;\\|&#x27;|\r|\n|\t|\u2028|\u2029&#x2F;g;

  &#x2F;&#x2F; JavaScript micro-templating, similar to John Resig&#x27;s implementation.
  &#x2F;&#x2F; Underscore templating handles arbitrary delimiters, preserves whitespace,
  &#x2F;&#x2F; and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    &#x2F;&#x2F; Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join(&#x27;|&#x27;) + &#x27;|$&#x27;, &#x27;g&#x27;);

    &#x2F;&#x2F; Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = &quot;__p+=&#x27;&quot;;
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return &#x27;\\&#x27; + escapes[match]; });
      source +=
        escape ? &quot;&#x27;+\n((__t=(&quot; + escape + &quot;))==null?&#x27;&#x27;:_.escape(__t))+\n&#x27;&quot; :
        interpolate ? &quot;&#x27;+\n((__t=(&quot; + interpolate + &quot;))==null?&#x27;&#x27;:__t)+\n&#x27;&quot; :
        evaluate ? &quot;&#x27;;\n&quot; + evaluate + &quot;\n__p+=&#x27;&quot; : &#x27;&#x27;;
      index = offset + match.length;
    });
    source += &quot;&#x27;;\n&quot;;

    &#x2F;&#x2F; If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = &#x27;with(obj||{}){\n&#x27; + source + &#x27;}\n&#x27;;

    source = &quot;var __t,__p=&#x27;&#x27;,__j=Array.prototype.join,&quot; +
      &quot;print=function(){__p+=__j.call(arguments,&#x27;&#x27;);};\n&quot; +
      source + &quot;return __p;\n&quot;;

    try {
      var render = new Function(settings.variable || &#x27;obj&#x27;, &#x27;_&#x27;, source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    &#x2F;&#x2F; Provide the compiled function source as a convenience for precompilation.
    template.source = &#x27;function(&#x27; + (settings.variable || &#x27;obj&#x27;) + &#x27;){\n&#x27; + source + &#x27;}&#x27;;

    return template;
  };

  &#x2F;&#x2F; Add a &quot;chain&quot; function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  &#x2F;&#x2F; OOP
  &#x2F;&#x2F; ---------------
  &#x2F;&#x2F; If Underscore is called as a function, it returns a wrapped object that
  &#x2F;&#x2F; can be used OO-style. This wrapper holds altered versions of all the
  &#x2F;&#x2F; underscore functions. Wrapped objects may be chained.

  &#x2F;&#x2F; Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  &#x2F;&#x2F; Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  &#x2F;&#x2F; Add all mutator Array functions to the wrapper.
  each([&#x27;pop&#x27;, &#x27;push&#x27;, &#x27;reverse&#x27;, &#x27;shift&#x27;, &#x27;sort&#x27;, &#x27;splice&#x27;, &#x27;unshift&#x27;], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == &#x27;shift&#x27; || name == &#x27;splice&#x27;) &amp;&amp; obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  &#x2F;&#x2F; Add all accessor Array functions to the wrapper.
  each([&#x27;concat&#x27;, &#x27;join&#x27;, &#x27;slice&#x27;], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    &#x2F;&#x2F; Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    &#x2F;&#x2F; Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);
if (!window.vo) {
	var vo = {};
	window.vo = vo;
}

&#x2F;**
 * VO defining structure to use for storing data in Metadata soup
 * @module MM_JSSyncEngine
 * @class vo.MetadataVO
 * @constructor
 * @param {String} name
 * @param {Object} metadataResponse
 * @param lastSync
 * @param {String} soupEntryId
 **&#x2F;
vo.MetadataVO = function(name, metadataResponse, lastSync, soupEntryId) {
	
	this.name;
	this.metadataResponse;
	this.lastSync;
	this._soupEntryId = soupEntryId;
	
	if (name != null)
		this.name = name;
		
	if (metadataResponse != null)
		this.metadataResponse = metadataResponse;
		
	if (lastSync != null)
		this.lastSync = lastSync;
		
	if (soupEntryId != null)
		this._soupEntryId = soupEntryId;
	
	&#x2F;&#x2F;logToConsole(&quot;Metadata vo created for &quot; + name);
	return this;
}
&#x2F;**
Salesforce.com AJAX Connector 25.0
Copyright, 1999, salesforce.com, inc.
All Rights Reserved
@module SalesforceAjaxToolkit
@class sforce
*&#x2F;

var sforce;

&#x2F;* check if sforce is already created by some other lib*&#x2F;
if (!sforce) {
    sforce = {};
}

&#x2F;**
 @property internal
 *&#x2F;
sforce.internal = {};

&#x2F;**
 StringBuffer
 @class sforce.StringBuffer
 @for sforce
 *&#x2F;

sforce.StringBuffer = function() {
    this.buffer = [];

    this.append = function (s) {
        this.buffer.push(s);
        return this;
    };

    this.toString = function() {
        return this.buffer.join(&quot;&quot;);
    };
};

&#x2F;** 
 @class sforce.Base64Binary
 @for sforce
 @param text
 @constructor
*&#x2F;
sforce.Base64Binary = function(text) {
    this.input = text;
};

&#x2F;**
 *  @property keystr
 *  @for sforce.Base64Binary
**&#x2F;
sforce.Base64Binary.prototype.keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;=&quot;;

&#x2F;**
 *  @method toString
 *  @for sforce.Base64Binary
**&#x2F;
sforce.Base64Binary.prototype.toString = function() {
    var output = [];
    var chr1, chr2, chr3 = &quot;&quot;;
    var enc1, enc2, enc3, enc4 = &quot;&quot;;
    var i = 0;
    do {
        chr1 = this.input.charCodeAt(i++);
        chr2 = this.input.charCodeAt(i++);
        chr3 = this.input.charCodeAt(i++);
        enc1 = chr1 &gt;&gt; 2;
        enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
        enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6);
        enc4 = chr3 &amp; 63;
        if (isNaN(chr2)) {
            enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
            enc4 = 64;
        }
        output.push(this.keyStr.charAt(enc1) + this.keyStr.charAt(enc2) + this.keyStr.charAt(enc3) + this.keyStr.charAt(enc4));
        chr1 = chr2 = chr3 = &quot;&quot;;
        enc1 = enc2 = enc3 = enc4 = &quot;&quot;;
    } while (i &lt; this.input.length);
    return output.join(&quot;&quot;);
};

&#x2F;**
 *  @method decode
 *  @for sforce.Base64Binary
**&#x2F;
sforce.Base64Binary.prototype.decode = function(input) {
    var output = [];
    var chr1, chr2, chr3 = &quot;&quot;;
    var enc1, enc2, enc3, enc4 = &quot;&quot;;
    var i = 0;
    var base64test = &#x2F;[^A-Za-z0-9\+\&#x2F;\=]&#x2F;g;
    if (base64test.exec(input)) {
        alert(&quot;There were invalid base64 characters in the input text.\n&quot; +
              &quot;Valid base64 characters are A-Z, a-z, 0-9, &#x27;+&#x27;, &#x27;&#x2F;&#x27;, and &#x27;=&#x27;\n&quot; + &quot;Expect errors in decoding.&quot;);
    }
    input = input.replace(&#x2F;[^A-Za-z0-9\+\&#x2F;\=]&#x2F;g, &quot;&quot;);
    do {
        enc1 = this.keyStr.indexOf(input.charAt(i++));
        enc2 = this.keyStr.indexOf(input.charAt(i++));
        enc3 = this.keyStr.indexOf(input.charAt(i++));
        enc4 = this.keyStr.indexOf(input.charAt(i++));
        chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
        chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
        chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;
        output.push(String.fromCharCode(chr1));
        if (enc3 != 64) {
            output.push(String.fromCharCode(chr2));
        }
        if (enc4 != 64) {
            output.push(String.fromCharCode(chr3));
        }
        chr1 = chr2 = chr3 = &quot;&quot;;
        enc1 = enc2 = enc3 = enc4 = &quot;&quot;;
    } while (i &lt; input.length);
    return output.join(&quot;&quot;);
};

&#x2F;* DateCodec.js*&#x2F;


&#x2F;**
@method dateToString
@for sforce.internal
**&#x2F;
sforce.internal.dateToString = function(theDate) {
    var today = theDate;
    var year = today.getFullYear();
    var month = today.getMonth() + 1;
    var day = today.getDate();
    return  year + &quot;-&quot; + month + &quot;-&quot; + day;
};

&#x2F;**
@method dateTimeToString
@for sforce.internal
**&#x2F;
sforce.internal.dateTimeToString = function(theDate) {
    var today = theDate;
    var year = today.getFullYear();
    var month = today.getMonth() + 1;
    var day = today.getDate();
    var hour = today.getHours();
    var minute = today.getMinutes();
    var second = today.getSeconds();

    var offset = today.getTimezoneOffset();
    var pm = (offset &lt; 0) ? &quot;+&quot; : &quot;-&quot;;
    offset = Math.abs(offset);
    var hourdifference = offset &#x2F; 60;
    var minutedifference = offset % 60;

    if (second &lt;= 9) {
        second = &quot;0&quot; + second;
    }

    var milli = today.getMilliseconds();
    if (milli !== 0) {
        milli = &quot;.&quot; + milli;
        if (milli.length &gt; 4) {
            milli = milli.substring(0, 4);
        }
        second = second + milli;
    }

    var timezone;

    if (offset === 0) {
        timezone = &quot;Z&quot;;
    } else {
        if (minutedifference &lt; 10) {
            minutedifference = &quot;0&quot; + minutedifference;
        }
        if (hourdifference &lt; 10) {
            hourdifference = &quot;0&quot; + hourdifference;
        }
        timezone = pm + hourdifference + &quot;:&quot; + minutedifference;
    }

    if (month &lt;= 9) {
        month = &quot;0&quot; + month;
    }
    if (day &lt;= 9) {
        day = &quot;0&quot; + day;
    }
    if (hour &lt;= 9) {
        hour = &quot;0&quot; + hour;
    }
    if (minute &lt;= 9) {
        minute = &quot;0&quot; + minute;
    }

    return  year + &quot;-&quot; + month + &quot;-&quot; + day + &quot;T&quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second + timezone;
};


&#x2F;**
@method stringToDate
@for sforce.internal
**&#x2F;
sforce.internal.stringToDate = function(source) {
    var bc = false;
    if (source === null || source.length === 0) {
        throw &quot;Unable to parse dateTime&quot;;
    }

    if (source.charAt(0) == &#x27;+&#x27;) {
        source = source.substring(1);
    }

    if (source.charAt(0) == &#x27;-&#x27;) {
        source = source.substring(1);
        bc = true;
    }

    if (source.length != 10) {
        throw (&quot;Unable to parse date, &quot; + source + &quot; length != 10&quot;);
    }

    if (source.charAt(4) != &#x27;-&#x27; || source.charAt(7) != &#x27;-&#x27;) {
        throw (&quot;Unable to parse date&quot;);
    }

    var year = source.substring(0, 4);
    var month = source.substring(5, 7);
    var day = source.substring(8, 10);

    var date = new Date(year, month-1, day, 0, 0, 0);
    date.setMilliseconds(0);
    return date;
};


&#x2F;**
@method stringToDateTime
@for sforce.internal
**&#x2F;
sforce.internal.stringToDateTime = function(source) {
    var bc = false;
    if (source === null || source.length === 0) {
        throw &quot;Unable to parse dateTime&quot;;
    }

    if (source.charAt(0) == &#x27;+&#x27;) {
        source = source.substring(1);
    }
    if (source.charAt(0) == &#x27;-&#x27;) {
        source = source.substring(1);
        bc = true;
    }

    if (source.length &lt; 19) {
        throw (&quot;Unable to parse dateTime&quot;);
    }

    if (source.charAt(4) != &#x27;-&#x27; || source.charAt(7) != &#x27;-&#x27; ||
        source.charAt(10) != &#x27;T&#x27;) {
        throw (&quot;Unable to parse dateTime&quot;);
    }

    if (source.charAt(13) != &#x27;:&#x27; || source.charAt(16) != &#x27;:&#x27;) {
        throw (&quot;Unable to parse dateTime&quot;);
    }

    var year = source.substring(0, 4);
    var month = source.substring(5, 7);
    var day = source.substring(8, 10);
    var hour = source.substring(11, 13);
    var min = source.substring(14, 16);
    var sec = source.substring(17, 19);

    var date = new Date(year, month-1, day, hour, min, sec);

    var pos = 19;

    &#x2F;&#x2F; parse optional milliseconds
    if (pos &lt; source.length &amp;&amp; source.charAt(pos) == &#x27;.&#x27;) {
        var milliseconds = 0;
        var start = ++pos;
        while (pos &lt; source.length &amp;&amp; sforce.internal.isDigit(source.charAt(pos))) {
            pos++;
        }
        var decimal = source.substring(start, pos);
        if (decimal.length == 3) {
            milliseconds = decimal;
        } else if (decimal.length &lt; 3) {
            milliseconds = (decimal + &quot;000&quot;).substring(0, 3);
        } else {
            milliseconds = decimal.substring(0, 3);
            if (decimal.charAt(3) &gt;= &#x27;5&#x27;) {
                ++milliseconds;
            }
        }

        date.setMilliseconds(milliseconds);
    }

    var offset = date.getTimezoneOffset() * 60000;
    &#x2F;&#x2F;offset in milli;

    &#x2F;&#x2F; parse optional timezone
    if (pos + 5 &lt; source.length &amp;&amp;
        (source.charAt(pos) == &#x27;+&#x27; || (source.charAt(pos) == &#x27;-&#x27;))) {
        if (!sforce.internal.isDigit(source.charAt(pos + 1)) ||
            !sforce.internal.isDigit(source.charAt(pos + 2)) ||
            source.charAt(pos + 3) != &#x27;:&#x27; ||
            !sforce.internal.isDigit(source.charAt(pos + 4)) ||
            !sforce.internal.isDigit(source.charAt(pos + 5))) {
            throw &quot;Unable to parse dateTime&quot;;
        }
        var hours = (source.charAt(pos + 1) - &#x27;0&#x27;) * 10 + source.charAt(pos + 2) - &#x27;0&#x27;;
        var mins = (source.charAt(pos + 4) - &#x27;0&#x27;) * 10 + source.charAt(pos + 5) - &#x27;0&#x27;;
        var mseconds = (hours * 60 + mins) * 60 * 1000;

        &#x2F;&#x2F; subtract milliseconds from current date to obtain GMT
        if (source.charAt(pos) == &#x27;+&#x27;) {
            mseconds = -mseconds;
        }

        date = new Date(date.getTime() - offset + mseconds);
        pos += 6;
    }

    if (pos &lt; source.length &amp;&amp; source.charAt(pos) == &#x27;Z&#x27;) {
        pos++;
        date = new Date(date.getTime() - offset);
    }

    if (pos &lt; source.length) {
        throw (&quot;Unable to parse dateTime&quot;);
    }

    return date;
};

&#x2F;**
@method isDigit
@for sforce.internal
*&#x2F;
sforce.internal.isDigit = function (ch) {
    if (ch == &#x27;0&#x27; || ch == &#x27;1&#x27; || ch == &#x27;2&#x27; || ch == &#x27;3&#x27; || ch == &#x27;4&#x27; ||
        ch == &#x27;5&#x27; || ch == &#x27;6&#x27; || ch == &#x27;7&#x27; || ch == &#x27;8&#x27; || ch == &#x27;9&#x27;) {
        return true;
    } else {
        return false;
    }
};

&#x2F;* Xml *&#x2F;

&#x2F;**
 *  @class sforce.Xml
 *  @for sforce
 *  @constructor
 *  @param {String} name
**&#x2F;
sforce.Xml = function(name) {
};


&#x2F;**
@method toXml
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.toXml = function (sobjectNs, name, writer) {
    writer.writeStartElement(name, sobjectNs);
    if (this._xsiType) {
        writer.writeXsiType(this._xsiType);
    }
    for (var f in this) {
        if (&quot;_name&quot; == f || &quot;_xsiType&quot; == f) {
            &#x2F;&#x2F;skip
        } else {
            var val = this[f];
            if (typeof val != &quot;function&quot;) {
                if (typeof val == &quot;array&quot;) {
                    for (var i=0; i&lt;val.length; i++) {
                        this.writeValue(sobjectNs, writer, f, val[i]);
                    }
                } else {
                    this.writeValue(sobjectNs, writer, f, val);
                }
            }
        }
    }
    writer.writeEndElement(name, sobjectNs);
};


&#x2F;**
@method writeValue
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.writeValue = function (sobjectNs, writer, name, val) {
    if (val === null) {
        writer.writeNameValueNode(&quot;fieldsToNull&quot;, name);
        return;
    }
    if (typeof(val) === &quot;undefined&quot;) {
        &#x2F;&#x2F;TODO:  throw &quot;value for field &quot; + name + &quot; is undefined&quot;; Bug: 100000000000Ufg
        return; &#x2F;&#x2F;skip for now
    }
    if (val.toXml) {
        val.toXml(sobjectNs, name, writer);
    } else {
        writer.writeNameValueNode(name, val);
    }
};

&#x2F;**
@method get
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.get = function(name) {
    return this[name] ? this[name] : null;
};

&#x2F;**
@method set
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.set = function(name, value) {
    this[name] = value;
};

&#x2F;**
@method getArray
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getArray = function(name) {
    var obj = this[name];
    if (obj) {
        if (obj.join) {
            return obj;
        } else {
            return [obj];
        }
    } else {
        return [];
    }
};

&#x2F;**
@method getBoolean
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getBoolean = function(name) {
    return (&quot;true&quot; == this[name]) ? true : false;
};

&#x2F;**
@method getDate
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getDate = function(name) {
    if (this[name]) {
        if (this[name].getFullYear) {
            return this[name];
        } else {
            return sforce.internal.stringToDate(this[name]);
        }
    } else {
        return null;
    }
};

&#x2F;**
@method getDateTime
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getDateTime = function(name) {
    if (this[name]) {
        if (this[name].getFullYear) {
            return this[name];
        } else {
            return sforce.internal.stringToDateTime(this[name]);
        }
    } else {
        return null;
    }
};

&#x2F;**
@method getInt
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getInt = function(name) {
    if (this[name]) {
        if (typeof this[name] === &quot;number&quot;) {
            return this[name];
        } else {
            return parseInt(this[name], 10);
        }
    } else {
        throw &quot;Unable to parse int field: &quot; + name;
    }
};

&#x2F;**
@method getFloat
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getFloat = function(name) {
    if (this[name]) {
        if (typeof this[name] === &quot;number&quot;) {
            return this[name];
        } else {
            return parseFloat(this[name]);
        }
    } else {
        throw &quot;Unable to parse float field: &quot; + name;
    }
};

&#x2F;**
@method getBase64Binary
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.getBase64Binary = function(name) {
    if (this[name]) {
        return sforce.Base64Binary.prototype.decode(this[name]);
    } else {
        throw &quot;Unable to parse base64Binary field: &quot; + name;
    }
};

&#x2F;**
@method toString
@for sforce.Xml
**&#x2F;
sforce.Xml.prototype.toString = function() {
    var sb = new sforce.StringBuffer();
    sb.append(&quot;{&quot;);

    for (var f in this) {
        var field = this[f];

        if (!field) {
            sb.append(f).append(&quot;:&quot;).append(&quot;&quot; + field);
        } else  if (typeof(field) == &quot;object&quot;) {
            sb.append(f).append(&quot;:&quot;).append(field.toString());
        } else if (field.join) {
            sb.append(f).append(&quot;:&quot;).append(&quot;[&quot;);
            for (var i = 0; i &lt; field.length; i++) {
                sb.append(field[i]);
                if (i &lt; field.length - 1) {
                    sb.append(&quot;, &quot;);
                }
            }
            sb.append(&quot;]&quot;);
        } else if (typeof(field) == &quot;function&quot;) {
            continue;
        } else {
            sb.append(f).append(&quot;:&quot;).append(&quot;&#x27;&quot; + field + &quot;&#x27;&quot;);
        }
        sb.append(&quot;, &quot;);
    }

    sb.append(&quot;}&quot;);
    return sb.toString();
};


&#x2F;* Debug *&#x2F;


&#x2F;**
@method Debug
@for sforce.internal
**&#x2F;
sforce.internal.Debug = function() {
    this.output = null;
    this.trace = false;
    this.apexTrace = false;
    this.win = null;
    this.traceQueue = [];
    this.quiet = false;

    this.open = function() {
        this.println(&quot;&quot;, &quot;print&quot;);
    };

    this.println = function(s, type) {
        if (this.quiet) {
            return;
        }

        if (typeof(println) === &quot;function&quot;) {
            println(s, type);
            return;
        }

        if (this.win === null || !this.win.document) {
            this.output = null;
            this.win = window.open((typeof window.UserContext != &quot;undefined&quot;) ? UserContext.getUrl(&#x27;&#x2F;soap&#x2F;ajax&#x2F;25.0&#x2F;debugshell.html&#x27;) : &#x27;&#x2F;soap&#x2F;ajax&#x2F;25.0&#x2F;debugshell.html&#x27;, &#x27;&#x27;,
                    &#x27;width=800,height=400,toolbar=no,location=no,directories=no,alwaysRaised=yes,&#x27; +
                    &#x27;status=no,menubar=no,scrollbars=yes,copyhistory=yes,resizable=yes&#x27;);
        }

        if (this.output === null) {
            this.findOutput();
        }

        if (this.output !== null) {
            if (sforce.debug.traceQueue.length &gt; 0) {
                this.traceCallback();
            }
            this.win.println(s, type);
       } else {
            sforce.debug.traceQueue.push({message: s, type: type});
            setTimeout(sforce.debug.traceCallback, 1000);
        }
    };

    this.traceCallback = function() {
        sforce.debug.findOutput();

        if (sforce.debug.output === null) {
            setTimeout(sforce.debug.traceCallback, 1000);
            return;
        }

        for (var i=0; i&lt;sforce.debug.traceQueue.length; i++) {
            var element = sforce.debug.traceQueue[i];
            sforce.debug.win.println(element.message, element.type);
        }
        sforce.debug.traceQueue = [];
    };

    this.findOutput = function() {
        if (this.output === null) {
            this.output = this.win.document.getElementById(&quot;output&quot;);
        }
        return this.output;
    };

    this.logXml = function(str) {
        str = str.replace(&#x2F;&lt;&#x2F;g, &quot;&amp;lt;&quot;);
        str = str.replace(&#x2F;&gt;&#x2F;g, &quot;&amp;gt;&quot;);
        str = &quot;&lt;textarea cols=80 rows=5 wrap=hard&gt;&quot; + str + &quot;&lt;&#x2F;textarea&gt;&quot;;
        this.println(str, &quot;printxml&quot;);
    };

    this.log = function(str) {
        this.println(str, &quot;print&quot;);
    };

    this.logApex = function(response) {
        var start = response.indexOf(&quot;&lt;debugLog&gt;&quot;);
        var end = response.indexOf(&quot;&lt;&#x2F;debugLog&gt;&quot;);
        if (start === -1)
        	start = 0;
        else
        	start = start + &#x27;&lt;debugLog&gt;&#x27;.length;
        if (end === -1) end = response.length;
        var msg = response.substring(start, end);

        this.println(msg, &quot;printxml&quot;);
    };
};

&#x2F;**
 *  @property debug
**&#x2F;
sforce.debug = new sforce.internal.Debug();

&#x2F;* Transport *&#x2F;

sforce.internal._connections = [];

sforce.internal.ConnectionHolder = function(connection, callback) {
    this.connection = connection;
    this.callback = callback;
    this.timedout = false;
};

&#x2F;**
 *  @method Transport
 *  @param {String} url
**&#x2F;
sforce.Transport = function(url) {
    this.url = url;
    this.connection = null;

    this.newConnection = function() {
        try {
            this.connection = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;);
        } catch(e) {
            try {
                this.connection = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);
            } catch(e) {
                this.connection = new XMLHttpRequest();
            }
        }

        return this.connection;
    };

    this.send = function (envelope, callback, async, timeout) {
        this.newConnection();
        if (async) {
            this.connection.onreadystatechange = this.httpConnectionCallback;
        }
        var holder = new sforce.internal.ConnectionHolder(this.connection, callback);
        sforce.internal._connections.push(holder);
        this.connection.open(&quot;POST&quot;, this.url, async);
        this.connection.setRequestHeader(&quot;Content-Type&quot;, &quot;text&#x2F;xml; charset=UTF-8&quot;);
        this.connection.setRequestHeader(&quot;SOAPAction&quot;, &quot;\&quot;\&quot;&quot;);
        this.connection.setRequestHeader(&quot;Accept&quot;, &quot;text&#x2F;xml&quot;);
        &#x2F;&#x2F;this.connection.setRequestHeader(&quot;User-Agent&quot;, &quot;SFAJAX 1.0&quot;);
        this.connection.send(envelope);
        if (async &amp;&amp; typeof(timeout) !== &quot;undefined&quot;) {
            this.setTimeoutOn(holder, timeout);
        }
        if (!async) {
            this.httpConnectionCallback();
        }
    };

    this.setTimeoutOn = function (holder, timeout) {
        function abortConnection() {
            if (holder.connection.readyState !== 4) {
                holder.timedout = true;
                holder.connection.abort();
            }
        }
        setTimeout(abortConnection, timeout);
    };

    this.httpConnectionCallback = function () {

        for (var i = 0; i &lt; sforce.internal._connections.length; i++) {
            var holder = sforce.internal._connections[i];
            if (holder !== null) {
                if (holder.timedout) {
                    sforce.internal._connections[i] = null;
                    sforce.internal._connections.slice(i,1);
                    holder.callback.httpCallback(&quot;Remote invocation timed out&quot;, false);
                } else  if (holder.connection.readyState == 4) {
                    sforce.internal._connections[i] = null;
                    sforce.internal._connections.slice(i,1);
                    var success = holder.connection.status == 200;
                    if (sforce.debug.trace) {
                        sforce.debug.log(&quot;Response : status - &quot; + holder.connection.status);
                        sforce.debug.logXml(holder.connection.responseText);
                    }
                    if (sforce.debug.apexTrace) {
                        sforce.debug.logApex(holder.connection.responseText);
                    }
                    if (holder.connection.responseXML &amp;&amp; holder.connection.responseXML.documentElement) {
                        holder.callback.httpCallback(holder.connection.responseXML.documentElement, success);
                    } else {
                        holder.callback.httpCallback(&quot;Remote invocation failed, due to: &quot; + holder.connection.responseText +
                                                     &quot; status code: &quot;, holder.connection.status);
                    }
                }
            }
        }
    };
};

&#x2F;* XmlWriter *&#x2F;

&#x2F;**
 *  @class sforce.XmlWriter
 *  @for sforce
 *  @constructor
**&#x2F;
sforce.XmlWriter = function() {
    this.buffer = new sforce.StringBuffer();
    this.namespaces = {};
    this.prefixCount = 0;
    this.writingStartElement = false;
};

&#x2F;**
@method writeStartElement
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeStartElement = function(name, namesp, prefix) {
    if (this.writingStartElement) {
        this.buffer.append(&quot;&gt;&quot;);
    }
    this.buffer.append(&quot;&lt;&quot;);
    var newns = false;
    if (namesp) {
        if (!this.namespaces[namesp] &amp;&amp; this.namespaces[namesp] !== &quot;&quot;) {
            newns = true;
        }
        if (!prefix) {
            prefix = this.getPrefix(namesp);
        }
        if (prefix !== null &amp;&amp; prefix !== &quot;&quot;) {
           this.buffer.append(prefix);
           this.buffer.append(&quot;:&quot;);
        }
    }

    this.buffer.append(name);
    if (newns === true) {
        this.writeNamespace(namesp, prefix);
    }
    this.writingStartElement = true;
};

&#x2F;**
@method writeEndElement
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeEndElement = function(name, namesp) {
    if (this.writingStartElement) {
        this.buffer.append(&quot;&#x2F;&gt;&quot;);
    } else {
        this.buffer.append(&quot;&lt;&#x2F;&quot;);
        if (namesp) {
            var prefix = this.getPrefix(namesp);
            if (prefix &amp;&amp; prefix !== &quot;&quot;) {
              this.buffer.append(prefix);
              this.buffer.append(&quot;:&quot;);
            }
        }
        this.buffer.append(name);
        this.buffer.append(&quot;&gt;&quot;);
    }
    this.writingStartElement = false;
};

&#x2F;**
@method writeNamespace
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeNamespace = function(namesp, prefix) {
    if (prefix &amp;&amp; &quot;&quot; !== prefix) {
        this.namespaces[namesp] = prefix;
        this.buffer.append(&quot; &quot;);
        this.buffer.append(&quot;xmlns:&quot;);
        this.buffer.append(prefix);
    } else {
        this.namespaces[namesp] = &quot;&quot;;
        this.buffer.append(&quot; &quot;);
        this.buffer.append(&quot;xmlns&quot;);
    }
    this.buffer.append(&quot;=\&quot;&quot;);
    this.buffer.append(namesp);
    this.buffer.append(&quot;\&quot;&quot;);
};

&#x2F;**
@method writeText
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeText = function(text) {
    if (this.writingStartElement) {
        this.buffer.append(&quot;&gt;&quot;);
        this.writingStartElement = false;
    } else {
        throw &quot;Can only write text after a start element&quot;;
    }
    if (typeof text == &#x27;string&#x27;) {
        text = text.replace(&#x2F;&amp;&#x2F;g, &#x27;\&amp;amp;&#x27;);
        text = text.replace(&#x2F;&lt;&#x2F;g, &#x27;&amp;lt;&#x27;);
        text = text.replace(&#x2F;&gt;&#x2F;g, &#x27;&amp;gt;&#x27;);
    }

    this.buffer.append(text);
};

&#x2F;**
@method writeXsiType
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeXsiType = function(xsiType) {
    this.writeNamespace(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;, &quot;xsi&quot;);
    this.writeAttribute(&quot;xsi:type&quot;, xsiType);
};

&#x2F;**
@method writeAttribute
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeAttribute = function(name, value) {
    this.buffer.append(&quot; &quot; + name + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;);
};

&#x2F;**
@method getPrefix
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.getPrefix = function(namesp) {
    var prefix = this.namespaces[namesp];
    &#x2F;&#x2F;sforce.debug.log(&quot;--------&quot;);
    &#x2F;&#x2F;sforce.debug.log(namesp + &quot;:&quot; + (prefix === null ? &quot;null&quot;:prefix) + &quot;:&quot;);
    if (!prefix &amp;&amp; prefix !== &quot;&quot;) {
        prefix = &quot;ns&quot; + this.prefixCount;
        this.prefixCount++;
        this.namespaces[namesp] = prefix;
        return prefix;
    }
    return prefix;
};

&#x2F;**
@method toString
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.toString = function() {
    return this.buffer.toString();
};

&#x2F;**
@property soapNS
@for sforce.XmlWriter
*&#x2F;
sforce.XmlWriter.prototype.soapNS = &quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;;

&#x2F;**
@method startEnvelope
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.startEnvelope = function() {
    this.writeStartElement(&quot;Envelope&quot;, this.soapNS, &quot;se&quot;);
};

&#x2F;**
@method endEnvelope
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.endEnvelope = function() {
    this.writeEndElement(&quot;Envelope&quot;, this.soapNS);
};

&#x2F;**
@method startHeader
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.startHeader = function() {
    this.writeStartElement(&quot;Header&quot;, this.soapNS, &quot;se&quot;);
};

&#x2F;**
@method endHeader
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.endHeader = function() {
    this.writeEndElement(&quot;Header&quot;, this.soapNS);
};

&#x2F;**
@method startBody
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.startBody = function() {
    this.writeStartElement(&quot;Body&quot;, this.soapNS, &quot;se&quot;);
};

&#x2F;**
@method endBody
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.endBody = function() {
    this.writeEndElement(&quot;Body&quot;, this.soapNS);
};

&#x2F;**
@method writeNameValueNode
@for sforce.XmlWriter
**&#x2F;
sforce.XmlWriter.prototype.writeNameValueNode = function(name, value) {
    if (value === null) {
        this.writeStartElement(name);
        this.writeNamespace(&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;, &quot;xsi&quot;);
        this.writeAttribute(&quot;xsi:nill&quot;, &quot;true&quot;);
        this.writeEndElement(name);
        return;
    }

    if (value.toUTCString) {
        value = sforce.internal.dateTimeToString(value);
    }
    if (typeof value == &quot;boolean&quot;) {
        &#x2F;&#x2F; boolean &#x27;false&#x27; values get joined in string buffer,
        &#x2F;&#x2F; so convert to strings:
        value = value ? &quot;true&quot; : &quot;false&quot;;
    }

    if (value &amp;&amp; value.join) {
        for (var i=0; i&lt;value.length; i++) {
            this.writeStartElement(name);
            this.writeText(value[i]);
            this.writeEndElement(name);
        }
    } else {
        this.writeStartElement(name);
        this.writeText(value);
        this.writeEndElement(name);
    }
};

&#x2F;* XmlReader *&#x2F;

&#x2F;**
 *  @class sforce.XmlReader
 *  @for sforce
 *  @constructor
 *  @param root
**&#x2F;
sforce.XmlReader = function(root) {
    this.envelope = root;
};

&#x2F;**
@method getEnvelope
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getEnvelope = function() {
    if (this.isTag(&quot;Envelope&quot;, this.envelope)) {
        return this.envelope;
    }
    throw &quot;Unable to find soap envelope, but found &quot; + this.envelope.nodeName;
};

&#x2F;**
@method getBody
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getBody = function() {
    return this.getChild(&quot;Body&quot;, this.envelope);
};

&#x2F;**
@method getHeader
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getHeader = function() {
    return this.getChild(&quot;Header&quot;, this.envelope);
};

&#x2F;**
@method getChild
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getChild = function(name, node) {
    var children = node.childNodes;
    for (var i = 0; i &lt; children.length; i++) {
        if (children[i].nodeType == 1 &amp;&amp; this.isTag(name, children[i])) {
            return children[i];
        }
    }
    return null;
};

&#x2F;**
@method getFirstElement
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getFirstElement = function(node) {
    var children = node.childNodes;
    for (var i = 0; i &lt; children.length; i++) {
        if (children[i].nodeType == 1) {
            return children[i];
        }
    }
    return null;
};

&#x2F;**
@method isTag
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.isTag = function(name, node) {
    var ns = node.nodeName.split(&quot;:&quot;);
    if (ns.length == 2 &amp;&amp; ns[1] == name) {
        return true;
    }
    if (ns.length == 1 &amp;&amp; ns[0] == name) {
        return true;
    }
    return false;
};

&#x2F;**
@method isNameValueNode
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.isNameValueNode = function(node) {
    var children = node.childNodes;
    for (var i = 0; i &lt; children.length; i++) {
        if (children[i].nodeType != 3) {
            return false;
        }
    }

    return true;
};

&#x2F;**
@method getTextValue
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.getTextValue = function(node) {
    if (node.nodeType == 3) {
        return node.nodeValue;
    }
    &#x2F;&#x2F;todo: fix the hardcoded xsi prefix
    var xsiNil = node.getAttribute(&quot;xsi:nil&quot;);
    if (xsiNil == &quot;true&quot;) {
        return null;
    }
    var sb = &quot;&quot;;
    var children = node.childNodes;
    for (var i = 0; i &lt; children.length; i++) {
        if (children[i].nodeType == 3) {
            sb += children[i].nodeValue;
        } else {
            throw &quot;Not a simple name value node&quot;;
        }
    }
    return sb;
};

&#x2F;&#x2F;todo: optimize
&#x2F;*
&#x2F;**
@method toXmlObject2
@for sforce.XmlReader
**&#x2F;
&#x2F;*
sforce.XmlReader.prototype.toXmlObject2 = function(node) {
    var children = node.childNodes;
    var obj = new sforce.Xml();
    for (var i = 0; i &lt; children.length; i++) {
        var child = children[i];
        if (child.nodeType != 1) continue;
        var name = child.nodeName;
        var index = name.indexOf(&quot;:&quot;);
        name = (index == -1) ? name : name.substring(index + 1);
        var value;
        if (this.isNameValueNode(child)) {
            value = this.getTextValue(child);
        } else {
            value = this.toXmlObject(child);
        }
        this.addToObject(obj, name, value);
    }
    return obj;
}
*&#x2F;


&#x2F;**
@method toXmlObject
@for sforce.XmlReader
**&#x2F;
sforce.XmlReader.prototype.toXmlObject = function(n) {
    &#x2F;&#x2F;todo: fix the hardcoded xsi prefix
    var xsiNil = n.getAttribute(&quot;xsi:nil&quot;);
    if (xsiNil == &quot;true&quot;) {
        return null;
    }

    var top = new sforce.Xml();
    var stack = [];
    stack.push({node: n, obj: top});

    while (stack.length &gt; 0) {
        var st = stack.shift();

        for (var child = st.node.firstChild; child !== null; child = child.nextSibling) {
            if (child.nodeType != 1) {
                continue;
            }
            var name = child.nodeName;
            var index = name.indexOf(&quot;:&quot;);
            name = (index == -1) ? name : name.substring(index + 1);
            var value;

            var isNameValue = true;
            var sb = &quot;&quot;;
            for (var tc = child.firstChild; tc !== null; tc = tc.nextSibling) {
                if (tc.nodeType != 3) {
                    isNameValue = false;
                    break;
                } else {
                    sb += tc.nodeValue;
                }
            }

            if (isNameValue) {
                if (child.getAttribute(&quot;xsi:nil&quot;) == &quot;true&quot;) {
                    value = null;
                } else {
                    value = sb;
                }
            } else {
                value = new sforce.Xml();
                stack.push({node: child, obj: value});
            }
            if (!st.obj[name]) {
                st.obj[name] = value;
            } else {
                if (st.obj[name].push) {
                    st.obj[name].push(value);
                } else {
                    var old = st.obj[name];
                    if (name === &quot;Id&quot; &amp;&amp; old === value) {
                        &#x2F;&#x2F;skip, special case for dup Id in sobject
                    } else {
                        st.obj[name] = [];
                        st.obj[name].push(old);
                        st.obj[name].push(value);
                    }
                }
            }
        }
    }
    return top;
};


&#x2F;**
@class sforce.SoapTransport
@for sforce
*&#x2F;
sforce.SoapTransport = function() {
    this.connectionCallback = null;
    this.result = null;
    this.fault = null;
    this.isAsync = true;
    this.isArray = false;
};

&#x2F;**
@method onFailure
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.onFailure = function(res, writer) {
    var error = &quot;ERROR: ........... &quot;;
    alert(error + res);
    this.result = null;
};

&#x2F;**
@method send
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.send = function(url, writer, isArray, connectionCallback) {
    this.isArray = isArray;
    var transport = new sforce.Transport(url);
    this.isAsync = connectionCallback ? true : false;
    if (this.isAsync) {
        this.connectionCallback = connectionCallback;
        transport.send(writer.toString(), this, this.isAsync, connectionCallback.timeout);
    } else {
        transport.send(writer.toString(), this, this.isAsync);
        if (this.fault !== null) {
            throw this.fault;
        }
        return this.result;
    }
};

&#x2F;**
@event httpCallback
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.httpCallback = function(response, success) {
    try {
        if (success === true) {
            var reader = new sforce.XmlReader(response);
            var envelope = reader.getEnvelope();
            var body = reader.getBody();
            var operation = reader.getFirstElement(body);
            if (operation === null) {
                throw &quot;Unable to find operation response element&quot;;
            }
            var resultArray = [];
            var children = operation.childNodes;
            for (var i = 0; i &lt; children.length; i++) {
                if (children[i].nodeType != 1) {
                    continue;
                }
                if (reader.isNameValueNode(children[i])) {
                    resultArray.push(reader.getTextValue(children[i]));
                } else {
                    resultArray.push(reader.toXmlObject(children[i]));
                }
            }

            if (this.isArray) {
                this.result = resultArray;
            } else {
                if (resultArray.length &gt; 1) {
                    throw &quot;Found more than one response: &quot; + resultArray;
                }
                this.result = resultArray[0];
            }

            if (this.isAsync) {
            	try {
            		this.beforeCallback();
            		if (typeof this.connectionCallback == &quot;function&quot;) {
            			this.connectionCallback(this.result);
            		} else {
            			if (this.connectionCallback.onSuccess) {
            				this.connectionCallback.onSuccess(this.result, this.connectionCallback.source);
            			} else {
            				throw &quot;Unable to find onSuccess method in the callback object&quot;;
            			}
            		}
            	} finally {
            		this.afterCallback();
            	}
            }
        } else {
            if (typeof(response.nodeName) !== &quot;undefined&quot;) {
                var reader2 = new sforce.XmlReader(response);
                var envelope2 = reader2.getEnvelope();
                var body2 = reader2.getBody();
                var soapfaultEl = reader2.getFirstElement(body2);
                var soapfault = reader2.toXmlObject(soapfaultEl);
                this.sendFault(soapfault);
            } else {
                this.sendFault(response);
            }
        }
    } catch(fault) {
        this.sendFault(fault);
    }
};


&#x2F;**
@event sendFault
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.sendFault = function(fault) {
    if (this.isAsync) {
        if (this.connectionCallback.onFailure) {
        	try {
        		this.beforeCallback();
        		this.connectionCallback.onFailure(fault, this.connectionCallback.source);
        	} finally {
        		this.afterCallback();
        	}
        } else {
            this.onFailure(fault);
        }
    } else {
        this.fault = fault;
    }
};

&#x2F;**
@event beforeCallback
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.beforeCallback = function () {};

&#x2F;**
@event afterCallback
@for sforce.SoapTransport
**&#x2F;
sforce.SoapTransport.prototype.afterCallback = function () {};

&#x2F;** 
@class sforce.SObject
@for sforce
*&#x2F;
sforce.SObject = function(type) {
    this.type = type;
};

sforce.SObject.prototype = new sforce.Xml(&quot;sObjects&quot;);


&#x2F;**
@class sforce.LeadConvert
@for sforce
*&#x2F;
sforce.LeadConvert = function() {
};

sforce.LeadConvert.prototype = new sforce.Xml(&quot;leadConverts&quot;);

&#x2F;** 
@class sforce.MergeRequest
@for sforce
*&#x2F;
sforce.MergeRequest = function() {
};

sforce.MergeRequest.prototype = new sforce.Xml(&quot;request&quot;);


&#x2F;** 
@class sforce.Connection
@for sforce
*&#x2F;
sforce.Connection = function() {
    this.sessionId = null;
    this.updateMru = null;
    this.allowFieldTruncation = null;
    this.disableFeedTracking = null;
    this.streamingEnabled = null;
    this.allOrNone = null;
    this.client = null;
    this.defaultNamespace = null;
    this.batchSize = null;
    this.loginScopeHeader = null;
    this.emailHeader = null;
    this.assignmentRuleHeader = null;
    this.transferToUserId = null;
    this.debuggingHeader = null;
    this.serverUrl = (typeof window.UserContext != &quot;undefined&quot;) ? UserContext.getUrl(&quot;&#x2F;services&#x2F;Soap&#x2F;u&#x2F;25.0&quot;) : &quot;&#x2F;services&#x2F;Soap&#x2F;u&#x2F;25.0&quot;;
};


&#x2F;* internal methods *&#x2F;

sforce.internal.Parameter = function (n, v, a) {
    this.name = n;
    this.value = v;
    this.isArray = a;
};

sforce.Connection.prototype.sforceNs = &quot;urn:partner.soap.sforce.com&quot;;
sforce.Connection.prototype.sobjectNs = &quot;sobject.partner.soap.sforce.com&quot;;

sforce.Connection.prototype.writeOne = function (writer, name, value, sobjectNs) {
    if (value === null) {
        writer.writeNameValueNode(name, null);
    } else if (value.toXml) {
        value.toXml(sobjectNs, name, writer);
    } else {
        writer.writeNameValueNode(name, value);
    }
};

sforce.Connection.prototype.init = function(sessionId, serverUrl) {
    this.sessionId = sessionId;
    this.serverUrl = serverUrl;
};

sforce.Connection.prototype.login = function (username, password) {
    var arg1 = new sforce.internal.Parameter(&quot;username&quot;, username, false);
    var arg2 = new sforce.internal.Parameter(&quot;password&quot;, password, false);
    var result = this.invoke(&quot;login&quot;, [arg1, arg2], false, null);
    this.sessionId = result.sessionId;
    return result;
};

sforce.Connection.prototype.describeSObject = function(type, callback) {
    var arg = new sforce.internal.Parameter(&quot;sObjectType&quot;, type, false);
    return this.invoke(&quot;describeSObject&quot;, [arg], false, callback);
};

sforce.Connection.prototype.describeSObjects = function(types, callback) {
    var arg = new sforce.internal.Parameter(&quot;sObjectType&quot;, types, true);
    return this.invoke(&quot;describeSObjects&quot;, [arg], true, callback);
};

sforce.Connection.prototype.describeGlobal = function(callback) {
    return this.invoke(&quot;describeGlobal&quot;, [], false, callback);
};

sforce.Connection.prototype.describeLayout = function(type, recordTypes, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;sObjectType&quot;, type, false);
    if (!recordTypes) {
        recordTypes = [];
    }
    var arg2 = new sforce.internal.Parameter(&quot;recordTypeIds&quot;, recordTypes, true);
    return this.invoke(&quot;describeLayout&quot;, [arg1, arg2], false, callback);
};

sforce.Connection.prototype.describeTabs = function(callback) {
    return this.invoke(&quot;describeTabs&quot;, [], true, callback);
};

sforce.Connection.prototype.describeSoftphoneLayout = function(callback) {
    return this.invoke(&quot;describeSoftphoneLayout&quot;, [], false, callback);
};

sforce.Connection.prototype.describeMiniLayout = function (type, recordTypeIds, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;sObjectType&quot;, type, false);
    var arg2 = new sforce.internal.Parameter(&quot;recordTypeIds&quot;, recordTypeIds, true);
    return this.invoke(&quot;describeMiniLayout&quot;, [arg1, arg2], false, callback);
};


sforce.Connection.prototype.create = function (sobjects, callback) {
    var arg = new sforce.internal.Parameter(&quot;sObjects&quot;, sobjects, true);
    return this.invoke(&quot;create&quot;, [arg], true, callback);
};

sforce.Connection.prototype.update = function (sobjects, callback) {
    var arg = new sforce.internal.Parameter(&quot;sObjects&quot;, sobjects, true);
    return this.invoke(&quot;update&quot;, [arg], true, callback);
};

sforce.Connection.prototype.upsert = function (externalIDFieldName, sobjects, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;externalIDFieldName&quot;, externalIDFieldName, false);
    var arg2 = new sforce.internal.Parameter(&quot;sObjects&quot;, sobjects, true);
    return this.invoke(&quot;upsert&quot;, [arg1, arg2], true, callback);
};

sforce.Connection.prototype.deleteIds = function (ids, callback) {
    var arg = new sforce.internal.Parameter(&quot;ids&quot;, ids, true);
    return this.invoke(&quot;delete&quot;, [arg], true, callback);
};

sforce.Connection.prototype.impersonateUser = function (ids, callback) {
    var arg = new sforce.internal.Parameter(&quot;ids&quot;, ids, true);
    return this.invoke(&quot;impersonateUser&quot;, [arg], true, callback);
};
sforce.Connection.prototype.query = function(queryString, callback) {
    var arg = new sforce.internal.Parameter(&quot;queryString&quot;, queryString, false);
    return this.invoke(&quot;query&quot;, [arg], false, callback);
};

sforce.Connection.prototype.queryAll = function(queryString, callback) {
    var arg = new sforce.internal.Parameter(&quot;queryString&quot;, queryString, false);
    return this.invoke(&quot;queryAll&quot;, [arg], false, callback);
};

sforce.Connection.prototype.queryMore = function(queryLocator, callback) {
    var arg = new sforce.internal.Parameter(&quot;queryLocator&quot;, queryLocator, false);
    return this.invoke(&quot;queryMore&quot;, [arg], false, callback);
};

sforce.Connection.prototype.retrieve = function(fieldList, sObjectType, ids, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;fieldList&quot;, fieldList, false);
    var arg2 = new sforce.internal.Parameter(&quot;sObjectType&quot;, sObjectType, false);
    var arg3 = new sforce.internal.Parameter(&quot;ids&quot;, ids, true);
    return this.invoke(&quot;retrieve&quot;, [arg1, arg2, arg3], true, callback);
};

sforce.Connection.prototype.getUserInfo = function(callback) {
    return this.invoke(&quot;getUserInfo&quot;, [], false, callback);
};

sforce.Connection.prototype.resetPassword = function(userId, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;userId&quot;, userId, false);
    return this.invoke(&quot;resetPassword&quot;, [arg1], false, callback);
};

sforce.Connection.prototype.setPassword = function(userId, password, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;userId&quot;, userId, false);
    var arg2 = new sforce.internal.Parameter(&quot;password&quot;, password, false);
    return this.invoke(&quot;setPassword&quot;, [arg1, arg2], false, callback);
};

sforce.Connection.prototype.search = function(searchString, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;searchString&quot;, searchString, false);
    return this.invoke(&quot;search&quot;, [arg1], false, callback);
};

sforce.Connection.prototype.getDeleted = function(sObjectType, startDate, endDate, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;sObjectType&quot;, sObjectType, false);
    var arg2 = new sforce.internal.Parameter(&quot;startDate&quot;, startDate, false);
    var arg3 = new sforce.internal.Parameter(&quot;endDate&quot;, endDate, false);
    return this.invoke(&quot;getDeleted&quot;, [arg1, arg2, arg3], false, callback);
};

sforce.Connection.prototype.getUpdated = function(sObjectType, startDate, endDate, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;sObjectType&quot;, sObjectType, false);
    var arg2 = new sforce.internal.Parameter(&quot;startDate&quot;, startDate, false);
    var arg3 = new sforce.internal.Parameter(&quot;endDate&quot;, endDate, false);
    return this.invoke(&quot;getUpdated&quot;, [arg1, arg2, arg3], false, callback);
};


sforce.Connection.prototype.getServerTimestamp = function(callback) {
    return this.invoke(&quot;getServerTimestamp&quot;, [], false, callback);
};

sforce.Connection.prototype.convertLead = function(leadConverts, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;leadConverts&quot;, leadConverts, true);
    return this.invoke(&quot;convertLead&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.merge = function(mergeRequest, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;request&quot;, mergeRequest, true);
    return this.invoke(&quot;merge&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.undelete = function(ids, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;ids&quot;, ids, true);
    return this.invoke(&quot;undelete&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.process = function(actions, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;actions&quot;, actions, true);
    return this.invoke(&quot;process&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.sendEmail = function(messages, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;messages&quot;, messages, true);
    return this.invoke(&quot;sendEmail&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.emptyRecycleBin = function(ids, callback) {
    var arg1 = new sforce.internal.Parameter(&quot;ids&quot;, ids, true);
    return this.invoke(&quot;emptyRecycleBin&quot;, [arg1], true, callback);
};

sforce.Connection.prototype.invalidateSessions = function(sessionIds, callback) {
    var arg = new sforce.internal.Parameter(&quot;sessionIds&quot;, sessionIds, true);
    return this.invoke(&quot;invalidateSessions&quot;, [arg], true, callback);
};

sforce.Connection.prototype.logout = function(callback) {
    return this.invoke(&quot;logout&quot;, [], true, callback);
};

sforce.Connection.prototype.remoteFunction = function(args) {
    if (!args.url) {
        throw &quot;url not defined&quot;;
    }
    if (!args.onSuccess) {
        throw &quot;onSuccess method not defined&quot;;
    }

    if (!args.method) {
        args.method = &quot;GET&quot;;
    }
    if (!args.mimeType) {
        args.mimeType = &quot;text&#x2F;plain&quot;;
    }

    if (typeof(args.async) == &#x27;undefined&#x27;) {
        args.async = true;
    }

    if (typeof(args.cache) == &#x27;undefined&#x27;) {
        args.cache = false;
    }

    if (!(args.mimeType == &quot;text&#x2F;plain&quot; ||
          args.mimeType == &quot;text&#x2F;xml&quot;)) {
        throw &quot;Unknown mime type &quot; + args.mimeType;
    }

    if (sforce.debug.trace) {
        sforce.debug.log(&quot;Open connection to ... &quot; + args.url);
    }

    var request = new sforce.Transport().newConnection();
    var proxyUrl = (typeof window.UserContext != &quot;undefined&quot;) ? UserContext.getUrl(&quot;&#x2F;services&#x2F;proxy&quot;) : &quot;&#x2F;services&#x2F;proxy&quot;;
    if (args.cache) {
        proxyUrl = proxyUrl + &quot;?end-point-url=&quot; + args.url;
    } else {
        proxyUrl = proxyUrl + &quot;?no-cache=&quot; + new Date().getTime();
    }
    request.open(args.method, proxyUrl, args.async);

    if (args.requestHeaders) {
        for (var k in args.requestHeaders) {
            if (typeof args.requestHeaders[k] != &quot;function&quot;) {
                request.setRequestHeader(k, args.requestHeaders[k]);
            }
        }
    }

    request.setRequestHeader(&quot;SalesforceProxy-Endpoint&quot;, args.url);
    request.setRequestHeader(&quot;SalesforceProxy-SID&quot;, this.sessionId);

    if (args.async) {
        request.onreadystatechange = _remoteFunctionCallback;
    }

    if (sforce.debug.trace) {
        sforce.debug.log(&quot;Sending ...&quot;);
    }

    if (args.requestData) {
        request.send(args.requestData);
    } else {
        request.send(null);
    }

    if (sforce.debug.trace) {
        sforce.debug.log(&quot;Done Sending ...&quot;);
    }

    if (!args.async) {
        _remoteFunctionCallback();
    }

    function _remoteFunctionCallback() {
        if (sforce.debug.trace) {
            sforce.debug.log(&quot;callback called ...&quot;);
        }
        if (request.readyState == 4) {
            if (request.status == 200) {
                if (args.mimeType == &quot;text&#x2F;plain&quot;) {
                    args.onSuccess(request.responseText, request);
                } else if (args.mimeType == &quot;text&#x2F;xml&quot;) {
                    if (!request.responseXML || !request.responseXML.documentElement) {
                        throw &quot;Response not text&#x2F;xml mime type: &quot; + request.responseText;
                    }
                    args.onSuccess(request.responseXML.documentElement, request);
                } else {
                    throw &quot;unsupported mime type: &quot; + args.mimeType;
                }
            } else {
                if (args.onFailure) {
                    args.onFailure(request.responseText, request);
                } else {
                    sforce.debug.log(request.responseText);
                }
            }
        }
    }
};


sforce.Connection.prototype.writeHeader = function(writer, headerNs) {
    writer.startHeader();

    writer.writeNamespace(headerNs, &quot;sfns&quot;);

    if (this.sessionId !== null) {
        writer.writeStartElement(&quot;SessionHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;sessionId&quot;, this.sessionId);
        writer.writeEndElement(&quot;SessionHeader&quot;, headerNs);
    }
    if (typeof(this.organizationId) !== &quot;undefined&quot;) {
        throw &quot;Use sforce.connection.loginScopeHeader.organizationId instead of sforce.connection.organizationId&quot;;
    }
    if (this.loginScopeHeader !== null) {
        writer.writeStartElement(&quot;LoginScopeHeader&quot;, headerNs);
        if (this.loginScopeHeader.organizationId !== null) {
            writer.writeNameValueNode(&quot;organizationId&quot;, this.loginScopeHeader.organizationId);
        }
        if (this.loginScopeHeader.portalId !== null) {
            writer.writeNameValueNode(&quot;portalId&quot;, this.loginScopeHeader.portalId);
        }
        writer.writeEndElement(&quot;LoginScopeHeader&quot;, headerNs);
    }
    if (this.client !== null || this.defaultNamespace !== null) {
        writer.writeStartElement(&quot;CallOptions&quot;, headerNs);
        if (this.client !== null) {
            writer.writeNameValueNode(&quot;client&quot;, this.client);
        }
        if (this.defaultNamespace !== null) {
            writer.writeNameValueNode(&quot;defaultNamespace&quot;, this.defaultNamespace);
         }
        writer.writeEndElement(&quot;CallOptions&quot;, headerNs);
    }
    if (this.batchSize !== null) {
        writer.writeStartElement(&quot;QueryOptions&quot;, headerNs);
        writer.writeNameValueNode(&quot;batchSize&quot;, this.batchSize);
        writer.writeEndElement(&quot;QueryOptions&quot;, headerNs);
    }
    if (this.allowFieldTruncation !== null) {
        writer.writeStartElement(&quot;AllowFieldTruncationHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;allowFieldTruncation&quot;, this.allowFieldTruncation);
        writer.writeEndElement(&quot;AllowFieldTruncationHeader&quot;, headerNs);
    }
    if (this.disableFeedTracking !== null) {
        writer.writeStartElement(&quot;DisableFeedTrackingHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;disableFeedTracking&quot;, this.disableFeedTracking);
        writer.writeEndElement(&quot;DisableFeedTrackingHeader&quot;, headerNs);
    }
    if (this.streamingEnabled !== null) {
        writer.writeStartElement(&quot;StreamingEnabledHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;StreamingEnabled&quot;, this.streamingEnabled);
        writer.writeEndElement(&quot;StreamingEnabledHeader&quot;, headerNs);
    }
    if (this.allOrNone !== null) {
        writer.writeStartElement(&quot;AllOrNoneHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;allOrNone&quot;, this.allOrNone);
        writer.writeEndElement(&quot;AllOrNoneHeader&quot;, headerNs);
    }
    if (this.updateMru !== null) {
        writer.writeStartElement(&quot;MruHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;updateMru&quot;, this.updateMru);
        writer.writeEndElement(&quot;MruHeader&quot;, headerNs);
    }
    if (this.emailHeader !== null) {
        writer.writeStartElement(&quot;EmailHeader&quot;, headerNs);
        if (this.emailHeader.triggerAutoResponseEmail) {
            writer.writeNameValueNode(&quot;triggerAutoResponseEmail&quot;, this.emailHeader.triggerAutoResponseEmail);
        }
        if (this.emailHeader.triggerOtherEmail) {
            writer.writeNameValueNode(&quot;triggerOtherEmail&quot;, this.emailHeader.triggerOtherEmail);
        }
        if (this.emailHeader.triggerUserEmail) {
            writer.writeNameValueNode(&quot;triggerUserEmail&quot;, this.emailHeader.triggerUserEmail);
        }
        writer.writeEndElement(&quot;EmailHeader&quot;, headerNs);
    }
    if (this.assignmentRuleHeader !== null) {
        writer.writeStartElement(&quot;AssignmentRuleHeader&quot;, headerNs);
        if (this.assignmentRuleHeader.assignmentRuleId) {
            writer.writeNameValueNode(&quot;assignmentRuleId&quot;, this.assignmentRuleHeader.assignmentRuleId);
        }
        if (this.assignmentRuleHeader.useDefaultRule) {
            writer.writeNameValueNode(&quot;useDefaultRule&quot;, this.assignmentRuleHeader.useDefaultRule);
        }
        writer.writeEndElement(&quot;AssignmentRuleHeader&quot;, headerNs);
    }
    if (this.transferToUserId !== null) {
        writer.writeStartElement(&quot;UserTerritoryDeleteHeader&quot;, headerNs);
        writer.writeNameValueNode(&quot;transferToUserId&quot;, this.transferToUserId);
        writer.writeEndElement(&quot;UserTerritoryDeleteHeader&quot;, headerNs);
    }

    if (this.debuggingHeader !== null) {
        writer.writeStartElement(&quot;DebuggingHeader&quot;, headerNs);
        &#x2F;&#x2F; Write out old style if specified
        if (this.debuggingHeader.debugLevel) {
            writer.writeNameValueNode(&quot;debugLevel&quot;, this.debuggingHeader.debugLevel);
        }
        &#x2F;&#x2F; Write out the new style debugging categories and levels
        if (this.debuggingHeader.debugCategories) {
            var categories = this.debuggingHeader.debugCategories;
            for (var i = 0; i &lt; categories.length; i++) {
                var catAndLevel = categories[i].split(&quot;,&quot;);

                if (catAndLevel.length == 2) {
                    writer.writeStartElement(&quot;categories&quot;);
                    writer.writeNameValueNode(&quot;category&quot;, catAndLevel[0]);
                    writer.writeNameValueNode(&quot;level&quot;, catAndLevel[1]);
                    writer.writeEndElement(&quot;categories&quot;);
                }
            }
        }
        writer.writeEndElement(&quot;DebuggingHeader&quot;, headerNs);
    }

    writer.endHeader();
};

sforce.Connection.prototype.namespaceMap = [
{ns:sforce.Connection.prototype.sforceNs, prefix:null},
{ns:sforce.Connection.prototype.sobjectNs, prefix:&quot;ns1&quot;}
        ];

sforce.Connection.prototype.invoke = function(method, args, isArray, callback) {
    return this._invoke(method, args, isArray, callback, this.namespaceMap, this.serverUrl, this.sforceNs, this.sobjectNs);
};

sforce.Connection.prototype._invoke = function(method, args, isArray, callback, namespaces, url, headerNs, sobjectNs) {
    if (callback) {
        if (typeof(callback) == &quot;function&quot;) {
        } else {
            if (!callback.onSuccess) {
                throw &quot;onSuccess not defined in the callback&quot;;
            }
            if (!callback.onFailure) {
                throw &quot;onFailure not defined in the callback&quot;;
            }
        }
    }

    var writer = new sforce.XmlWriter();
    writer.startEnvelope();
    this.writeHeader(writer, headerNs);
    writer.startBody();
    writer.writeStartElement(method);

    for (var i = 0; i&lt;namespaces.length; i++) {
        writer.writeNamespace(namespaces[i].ns, namespaces[i].prefix);
    }

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        if (typeof(arg.value) === &quot;undefined&quot;) {
            throw &quot;arg &quot; + i + &quot; &#x27;&quot; + arg.name + &quot;&#x27; not specified&quot;;
        }
        if (arg.value !== null) {
            if (arg.isArray &amp;&amp; !arg.value.push) {
                throw &quot;arg &quot; + i + &quot; &#x27;&quot; + arg.name + &quot;&#x27; is an array. But passed in value is not an array&quot;;
            }
            if (!arg.isArray &amp;&amp; arg.value.push) {
                throw &quot;arg &quot; + i + &quot; &#x27;&quot; + arg.name + &quot;&#x27; is not an array. But passed in value is an array&quot;;
            }
        }
        if (arg.value === null) {
            this.writeOne(writer, arg.name, null, sobjectNs);
        } else if (arg.value.push) { &#x2F;&#x2F;this is an array
            for (var j = 0; j &lt; arg.value.length; j++) {
                var obj = arg.value[j];
                if (!obj) {
                    throw &quot;Array element at &quot; + j + &quot; is null.&quot;;
                }
                this.writeOne(writer, arg.name, obj, sobjectNs);
            }
        } else {
            this.writeOne(writer, arg.name, arg.value, sobjectNs);
        }
    }
    writer.writeEndElement(method);
    writer.endBody();
    writer.endEnvelope();
    if (sforce.debug.trace) {
        sforce.debug.log(&quot;Request: server- &quot; + url);
        sforce.debug.logXml(writer.toString());
    }
    var transport = new sforce.SoapTransport();
    return transport.send(url, writer, isArray, callback);
};


&#x2F;* QueryResultIterator *&#x2F;

sforce.QueryResultIterator = function(queryResult) {
    this.queryResult = queryResult;
    this.index = 0;
    this.records = this.queryResult.getArray(&quot;records&quot;);
};

sforce.QueryResultIterator.prototype.hasNext = function() {
    if (this.records.length &gt; this.index) {
        return true;
    }
    if (this.queryResult.queryLocator !== null) {
        this.queryResult = sforce.connection.queryMore(this.queryResult.queryLocator);
        this.records = this.queryResult.getArray(&quot;records&quot;);
        this.index = 0;
    }
    if (this.records.length &gt; this.index) {
        return true;
    } else {
        return false;
    }
};

sforce.QueryResultIterator.prototype.next = function() {
    if (this.records.length &gt; this.index) {
        var result = this.records[this.index];
        this.index++;
        return result;
    } else {
        throw &quot;Index out of bound : &quot; + this.index;
    }
};


&#x2F;* Email *&#x2F;


sforce.Email = function() {
};

sforce.Email.prototype = new sforce.Xml(&quot;messages&quot;);

sforce.MassEmailMessage = function() {
};

sforce.MassEmailMessage.prototype = new sforce.Xml(&quot;messages&quot;);
sforce.MassEmailMessage.prototype._xsiType = &quot;MassEmailMessage&quot;;



sforce.SingleEmailMessage = function() {
};

sforce.SingleEmailMessage.prototype = new sforce.Xml(&quot;messages&quot;);
sforce.SingleEmailMessage.prototype._xsiType = &quot;SingleEmailMessage&quot;;



&#x2F;* ProcessRequest *&#x2F;


sforce.ProcessRequest = function() {
};

sforce.ProcessRequest.prototype = new sforce.Xml(&quot;actions&quot;);

sforce.ProcessSubmitRequest = function() {
};

sforce.ProcessSubmitRequest.prototype = new sforce.Xml(&quot;actions&quot;);
sforce.ProcessSubmitRequest.prototype._xsiType = &quot;ProcessSubmitRequest&quot;;


sforce.ProcessWorkitemRequest = function() {
};

sforce.ProcessWorkitemRequest.prototype = new sforce.Xml(&quot;actions&quot;);
sforce.ProcessWorkitemRequest.prototype._xsiType = &quot;ProcessWorkitemRequest&quot;;
&#x2F;* set up connection *&#x2F;
sforce.connection = new sforce.Connection();

var UserContext = (typeof window.UserContext != &quot;undefined&quot;) ? window.UserContext : {
    siteUrlPrefix : &quot;&quot;,
    getUrl : function (url) {
        &#x2F;&#x2F; fix URL for sites with prefixes
        if (typeof url == &quot;undefined&quot; || typeof UserContext.siteUrlPrefix == &quot;undefined&quot; || !UserContext.siteUrlPrefix) 
            return url;

        if (url.indexOf(&#x27;&#x2F;&#x27;) != 0)
            return url;

        if(url.indexOf(UserContext.siteUrlPrefix) == 0)
            return url;

        return UserContext.siteUrlPrefix + url;
    }
};

if (typeof(__sfdcSiteUrlPrefix) != &quot;undefined&quot;) {
    UserContext.siteUrlPrefix = __sfdcSiteUrlPrefix;
}

sforce.connection.serverUrl = (typeof window.UserContext != &quot;undefined&quot;) ? UserContext.getUrl(&quot;&#x2F;services&#x2F;Soap&#x2F;u&#x2F;25.0&quot;) : &quot;&#x2F;services&#x2F;Soap&#x2F;u&#x2F;25.0&quot;;

if (typeof(__sfdcSessionId) != &quot;undefined&quot;) {
    sforce.connection.sessionId = __sfdcSessionId;
}


&#x2F;**
 *  Network utility class
 *  @module MM_JSSyncEngine
 *  @class Network
 *  @constructor
 *  @param {Function} onlineCallback
 *  @param {Function} offlineCallback
**&#x2F;

function Network (onlineCallback, offlineCallback) { 
	this.states = {};
	this.states[Connection.UNKNOWN]  = &#x27;Unknown connection&#x27;;
	this.states[Connection.ETHERNET] = &#x27;Ethernet connection&#x27;;
	this.states[Connection.WIFI]     = &#x27;WiFi connection&#x27;;
	this.states[Connection.CELL_2G]  = &#x27;Cell 2G connection&#x27;;
	this.states[Connection.CELL_3G]  = &#x27;Cell 3G connection&#x27;;
	this.states[Connection.CELL_4G]  = &#x27;Cell 4G connection&#x27;;
	this.states[Connection.NONE]     = &#x27;No network connection&#x27;;
	
	this.isConnected = false;
	this.callbackOnline = null;
	this.callbackOffline = null;
	if (window.device != null &amp;&amp; window.device.name == null) {
		document.addEventListener(&quot;deviceready&quot;, this.initialize, false);
	}
	else {
		if (onlineCallback != null) {
			this.onlineCallback = onlineCallback;
		}
		if (offlineCallback != null) {
			this.offlineCallback = offlineCallback;
		}
		this.initialize();
	}
	
	this.FAKE_OFFLINE = false;
	
}

&#x2F;**
 * Initialize network object
 * Checks initial network status and adds listeners for offline and online changes
 * @method initialize
 **&#x2F;
Network.prototype.initialize = function() {
	this.isConnected = this.handleNetworkStatusChange();
	
	document.addEventListener(&quot;online&quot;, this.checkConnection, false);
	document.addEventListener(&quot;offline&quot;, this.checkConnection, false);
	&#x2F;&#x2F;logToConsole(&#x27;Network initialized&#x27;);

}


&#x2F;**
 * Check the network status and set the Network object (this object) isConnected status.
 * If callback methods exist in this Network object for offline or online changes call those.
 * @method handleNetworkStatusChange
 **&#x2F;
Network.prototype.handleNetworkStatusChange = function() {
	logToConsole(&#x27;Network.handleNetworkStatusChange&#x27;);
    var networkState = navigator.network.connection.type;
	
	if(this.FAKE_OFFLINE || this.states[networkState] == this.states[Connection.NONE] || this.states[networkState] == this.states[Connection.UNKNOWN]){
		this.isConnected = false;
		logToConsole(&quot;Network is offline&quot;);
		if (this.callbackOffline != null) {
			this.callbackOffline();
		}
		return false;
	}
	else {
		this.isConnected = true;
		logToConsole(&quot;Network is online&quot;);
		if (this.callbackOnline != null) {
			this.callbackOnline();
		}
		return true;
	}
}
&#x2F;**
 *  OfflineQueue
 *  @module MM_JSSyncEngine
 *  @class OfflineQueue
 *  @constructor
**&#x2F;
function OfflineQueue() {
	this.objectSoupCount = 0;
	this.objectCount = 0;
	this.smartstore;
}


&#x2F;**
 * Queue for later upload
 * @method QueueRecords
 * @param {Array} records
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.QueueRecords = function(records,callback,error){
    &#x2F;&#x2F;DF12 DEMO 19 -- REGISTER QUEUE SOUP AND STORE QUEUE RECORDS
	logToConsole(&#x27;OfflineQueue.QueueRecords&#x27;);
	OfflineQueue.RegisterQueueSoup(function(){
		navigator.smartstore.upsertSoupEntriesWithExternalId(&#x27;Queue&#x27;, records, &#x27;Id&#x27;, function(results){
			logToConsole(&quot;OfflineQueue.QueueRecords() =&gt; Queue Upsert Success &quot; + JSON.stringify(results));
            OfflineQueue.UploadQueue(callback, error);
		}, error);
	},error);
}

&#x2F;**
 * Upload&#x2F;delete Queue to Salesforce
 * @method UploadQueue
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.UploadQueue = function(callback,error) {
	logToConsole(&quot;OfflineQueue.UploadQueue&quot;);
    var mmSync = window.mmSync;
	if(mmSync.network.isConnected) {
      	logToConsole(&quot;OfflineQueue.UploadQueue -- app is online&quot;);
        &#x2F;&#x2F;DF12 DEMO 23 -- UPLOAD QUEUE TO SFDC
		navigator.smartstore.soupExists(&#x27;Queue&#x27;,function(param){
			if(param)
			{
                logToConsole(&quot;OfflineQueue.UploadQueue -- Queue exists&quot;);
                &#x2F;&#x2F;Load sync.json
                var syncJsonObjs = window.syncJSON.objects;
                var syncJsonConfig = window.syncJSON.configuration;
                var upsertmethodAPIType = syncJsonConfig.upsertmethod;
                var deletemethodAPIType = syncJsonConfig.deletemethod;
				var upsertCompletes = false;
				var deleteCompletes = false;
				
				var soCount = 0;
				var syncJsonObj;
				
				var checkCompletes = function() {
					if (deleteCompletes &amp;&amp; upsertCompletes) {
						logToConsole(&quot;OfflineQueue.UploadQueue :: &quot; + syncJsonObj.name + &quot; is upserted and deleted&quot;);
						soCount++;
						if (soCount &lt; syncJsonObjs.length) {
							logToConsole(&quot;Calling process for object # &quot; + soCount + &quot; &#x2F; &quot; + syncJsonObjs.length);
							upsertCompletes = false;
							deleteCompletes = false;
							processObject(soCount);
						}
						else {
							logToConsole(&quot;All objects uploaded making callback&quot;);
							callback();
						}
					}
				}
				
				var handleLoadQueueRecords = function(records) {					
					var toDeleteCount = 0;
					var toUpsertCount = 0;
					upsertCompletes = false;
					deleteCompletes = false;
					
					if(records == null || records.length==0){
						console.log(&quot;OfflineQueue.UploadQueue -- no records in queue&quot;);
						deleteCompletes = true;
						upsertCompletes = true;
						checkCompletes();
						
					} 
					else {
						var upsertRecordsArray = new Array();
						var deleteRecordsArray = new Array();
						
						&#x2F;&#x2F; vars and methods for iterating through record set
						var isDelete;
						var thisRecord;
						var batchUp = false; &#x2F;&#x2F; Boolean to determine if batch upserts are used
						var batchDel = false; &#x2F;&#x2F; Boolean to determine if batch deletes are used
						
						var upsertSuccessCount = 0;
						var deleteSuccessCount = 0;					
						
						var QRCounter = 0
						logToConsole(&quot;OfflineQueue.UploadQueue -- iterating records&quot;);
						
						&#x2F;&#x2F;get delete&#x2F;upsert total counts
						for (QRCounter = 0; QRCounter &lt; records.length; QRCounter++) {
							if (OfflineQueue.checkIfQueueIsForDelete(records[QRCounter])) {
								toDeleteCount++;
							}
							else {
								toUpsertCount++;
							}
						}
						if (toUpsertCount == 0) {
							upsertCompletes = true;
						}
						if (toDeleteCount == 0) {
							deleteCompletes = true;
						}
						
						for (QRCounter = 0; QRCounter &lt; records.length; QRCounter++) {
							thisRecord = records[QRCounter];
							isDelete = OfflineQueue.checkIfQueueIsForDelete(thisRecord);
							
							if (isDelete &amp;&amp; deletemethodAPIType == &#x27;individual&#x27;) {
								logToConsole(&quot;Calling individual runSFDCDeleteQuery&quot;);
								
								OfflineQueue.runSFDCDeleteQuery(thisRecord, function() {
									logToConsole(&quot;Individual delete callback&quot;);
									deleteSuccessCount[syncJsonObj.name]++;
									if (deleteSuccessCount &gt;= toDeleteCount) {
										deleteCompletes = true;
										checkCompletes();
									}
								}, error); &#x2F;&#x2F;delete the record from SFDC and onsuccess delete from queue;
							}
							else if (isDelete &amp;&amp; deletemethodAPIType == &#x27;batch&#x27;) {
								deleteRecordsArray.push(thisRecord);
							}
							
							else if(!isDelete &amp;&amp; upsertmethodAPIType == &#x27;individual&#x27;) {									
								OfflineQueue.runSFDCUpsertQuery(thisRecord, syncJsonObjs, function() {
									logToConsole(&quot;Individual upsert callback&quot;);
									upsertSuccessCount++;
									if (upsertSuccessCount &gt;= toUpsertCount) {
										logToConsole(&quot;checking completes from Indvidual upsert&quot;);
										upsertCompletes = true;
										checkCompletes();
									}
								});
							}
							else if (!isDelete &amp;&amp; upsertmethodAPIType == &#x27;batch&#x27;) {
								upsertRecordsArray.push(records[QRCounter]);
							}
						}
						
						if (deletemethodAPIType == &#x27;batch&#x27; &amp;&amp; deleteRecordsArray.length &amp;&amp; deleteRecordsArray.length &gt; 0) {
							batchDel = true;
						}
						else if (deletemethodAPIType == &#x27;batch&#x27; &amp;&amp; (!deleteRecordsArray.length || deleteRecordsArray.length == 0)) {
							batchDel = true;
							deleteCompletes = true;
							
						}
						
						if (upsertmethodAPIType == &#x27;batch&#x27; &amp;&amp; upsertRecordsArray.length &amp;&amp; upsertRecordsArray.length &gt; 0) {
							batchUp = true;
						}
						else if (upsertmethodAPIType == &#x27;batch&#x27; &amp;&amp; (!upsertRecordsArray.length || upsertRecordsArray.length == 0)) {
							batchUp = true;
							upsertCompletes = true;
							checkCompletes();
						}
						
						if (batchDel &amp;&amp; deleteRecordsArray.length &amp;&amp; deleteRecordsArray.length &gt; 0) {
							OfflineQueue.runSFDCDeleteQueryUsingBatch(deleteRecordsArray, function() {
								deleteCompletes = true;
								
								if (batchUp) {
									logToConsole(&quot;Batch deletes complete, in callback with batchup&quot;);
									OfflineQueue.runSFDCUpsertQueryUsingBatch(upsertRecordsArray, syncJsonObjs, function() {
										upsertCompletes = true;
										checkCompletes();
									}, error);
								}
								else {
									logToConsole(&quot;Batch deletes complete, in callback without batchup&quot;);
									checkCompletes();
								}
							});
						}
						else if (batchUp &amp;&amp; upsertRecordsArray.length &amp;&amp; upsertRecordsArray.length &gt; 0) {
							OfflineQueue.runSFDCUpsertQueryUsingBatch(upsertRecordsArray,syncJsonObjs, function() {
								upsertCompletes = true;
								checkCompletes();
							}, error);
						}
						else {
							if (batchDel &amp;&amp; deleteRecordsArray.length &amp;&amp; deleteRecordsArray.length == 0) {
								deleteCompletes = true;
							}
							checkCompletes();
						}
						
					}
				}
				
                var processObject = function(soCount) { 
					syncJsonObj = syncJsonObjs[soCount];
					logToConsole(&quot;inside OfflineQueue.UploadQueue processObject for &quot; + syncJsonObj.name);
					if (typeof syncJsonObj.donotcache == &quot;undefined&quot; || !syncJsonObj.donotcache) {
						logToConsole(&quot;Calling OfflineQueue.UploadQueue LoadRecordsFromQueue for &quot; + syncJsonObj.name);
						OfflineQueue.LoadRecordsFromQueue(syncJsonObj, handleLoadQueueRecords, error);
					}
					else {
						&#x2F;&#x2F;TODO: Upsert record directly to salesforce without Cache if object is set to donotcache
						upsertCompletes = true;
						deleteCompletes = true;
						checkCompletes();
					}
                }
								
				processObject(soCount);
			}
			else {
				logToConsole(&quot;Offline queue doesn&#x27;t exist yet... must not be any records there...&quot;)
				callback();
			}
		},error);
	}
	else {
		logToConsole(&quot;We&#x27;re offline, can&#x27;t upload queue... how&#x27;d we even get here?&quot;)
		error(&quot;We&#x27;re offline, can&#x27;t upload queue... how&#x27;d we even get here?&quot;);
	}
}

&#x2F;**
 * Load records with Name from Queue
 * @method LoadRecordsFromQueue
 * @param {SyncObj} syncJsonObj - sync object from sync.json
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.LoadRecordsFromQueue = function(syncJsonObj,callback,error){
	console.log(&quot;OfflineQueue.loadRecordsFromQueue&quot;);
	var that=this;
    var soName=syncJsonObj.name;
    var querySpec = navigator.smartstore.buildExactQuerySpec(&quot;SObjectType&quot;, soName);
    navigator.smartstore.querySoup(&#x27;Queue&#x27;,querySpec, function(cursor) { 
		var records = [];
		logToConsole(&quot;QUERY SOUP RESULT: &quot; + JSON.stringify(cursor));
		if (cursor.currentPageOrderedEntries.length &gt; 0) {
			records = MMJSE_SmartStoreUtil.LoadAllRecords(cursor,records);
			navigator.smartstore.closeCursor(cursor);
			logToConsole(&#x27;records length here -- &#x27;+records.length);
			callback(records);
		}
		else {
			navigator.smartstore.closeCursor(cursor);
			callback(records);
		}
		&#x2F;&#x2F;close the query cursor
		
    },error);
}

&#x2F;**
 * this function will update the record in DB and call the Queue function
 * note: accepts only single record for queue
 * @method StoreRecords
 * @param {Array} records
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.StoreRecords = function(records,callback, error){
	logToConsole(&#x27;OfflineQueue.storeRecords&#x27;);
    var SObject = records[0].attributes.type;
    var operation = records[0].Operation;
    
    &#x2F;&#x2F;DF12 DEMO 9 -- SMARTSTORE UPSERT
    &#x2F;&#x2F;GOTO DF12 7
    &#x2F;&#x2F;@todo :: need to modify how this hanldes the records
    if(operation == &#x27;upsert&#x27;){
        logToConsole(&#x27;upsert this data to smart store DB&#x27;);
        var newRecord = records[0];
        &#x2F;&#x2F;delete newRecord.Operation;
        &#x2F;&#x2F;delete newRecord.SObjectType;
        navigator.smartstore.upsertSoupEntriesWithExternalId(SObject, [newRecord], &#x27;Id&#x27;, function(result){
			 	logToConsole(&quot;Soup Upsert Success for &quot; + SObject + &quot; Result is: &quot; + JSON.stringify(result));
				OfflineQueue.QueueRecords(records,callback, error);
			 }, error);
    }
    else if(operation == &#x27;delete&#x27;){
        logToConsole(&#x27;delete this record from smart store DB&#x27;);
        var deleteRecord = records[0];
        var _soupEntryId = deleteRecord._soupEntryId;
        &#x2F;&#x2F;delete newRecord.Operation;
        &#x2F;&#x2F;delete newRecord.SObjectType;
		var deleteIds = [];
		for (var d = 0; d &lt; records.lenght; d++) {
			deleteIds.push(records[d]._soupEntryId);
		}
        navigator.smartstore.removeFromSoup(SObject, deleteIds, function(){
				 console.log(&quot;Soup Record successfully deleted for &quot; + SObject);
				 OfflineQueue.QueueRecords(records,callback, error);
			 }, error);
    }

}

&#x2F;**
 * Register the Queue soup if it doesn&#x27;t already exist
 * @method RegisterQueueSoup
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.RegisterQueueSoup = function(callback,error){
	logToConsole(&#x27;OfflineQueue.registerQueueSoup&#x27;);
	&#x2F;&#x2F;check if the Password__c soup exists
	
	navigator.smartstore.soupExists(&#x27;Queue&#x27;,function(param){
		if(!param){
			&#x2F;&#x2F;Password__c soup doesn&#x27;t exist, so let&#x27;s register it
            var indexSpec=[{&quot;path&quot;:&quot;Id&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;path&quot;:&quot;Operation&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;path&quot;:&quot;SObjectType&quot;,&quot;type&quot;:&quot;string&quot;}];
			navigator.smartstore.registerSoup(&#x27;Queue&#x27;,indexSpec,function(param){
				logToConsole(&#x27;Soup Created: &#x27;+param);
				callback();
			},error);
		}
		else {
			logToConsole(&#x27;Queue soup exists&#x27;);
			callback();
		}
	},error);
}

&#x2F;*
@TODO: Create soup for Queue to store upserts&#x2F;deletes
*&#x2F;



&#x2F;**
 * Create Queue to store metadata for each object
 * @method createMetadataSoup
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.prototype.createMetadataSoup = function(callback,error) {
	navigator.smartstore.soupExists(&#x27;Metadata&#x27;,function(param){
		if(!param){
			&#x2F;&#x2F;Password__c soup doesn&#x27;t exist, so let&#x27;s register it
			var indexSpec = [{&quot;path&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;}];
			navigator.smartstore.registerSoup(&#x27;Metadata&#x27;,indexSpec, function(param){
				logToConsole(&#x27;Soup Created: &#x27;+param);
				if (callback != null) {
					callback();
				}
				else {
					logToConsole(&quot;No callback for createMetadataSoup&quot;);
				}
			},function(err) {
				if (typeof error != &quot;undefined&quot;) {
					error(err);
				}
				else {
					offlineQueue.handleSoupCreateError(err,&quot;Metadata&quot;);
				}
			});
		}
		else {
			callback();
		}
	},function(err) {
		var offlineQueue = window.offlineQueue;
		logToConsole(&quot;soupExists Error creating metadata: &quot; + err);
		if (error.match(&#x2F;not an error&#x2F;)) {
			offlineQueue.handleSoupCreateError(err,&quot;Metadata&quot;);
		}
		else if (typeof callback != undefined) {
			logToConsole(&quot;Error is not an errror, making callback&quot;);
			callback();
		}
		else {
			logToConsole(&quot;Error in createSoup for Metadata and callback not defined&quot;);
		}
	});
}

&#x2F;**
 * Write metadata record to Metadata
 * @method cacheMeta
 * @param {Object} sobj
 * @param {Object} metadataVo
 * @param {Function} callbackSuccess
 * @param {Function} callbackFail
 *&#x2F;
OfflineQueue.prototype.cacheMetadata = function(sobj, metadataVo, callbackSuccess, callbackFail) {
	logToConsole(&quot;Caching metaData response for &quot; + sobj);
	var cacheMeta = metadataVo;
	
	navigator.smartstore.upsertSoupEntriesWithExternalId(&quot;Metadata&quot;, [cacheMeta], &quot;name&quot;, callbackSuccess, callbackFail);
}

&#x2F;**
 * Update LastSync to Metadata
 * @method updateTimestamp
 * @param {Object} sobj
 * @param {DateTime} time
 * @param {Object} metadata
 * @param {Function} callback
 **&#x2F;
OfflineQueue.prototype.updateTimestamp = function(sobj,time, metadata, callback) {
	logToConsole(&quot;OfflineQueue :: updateTimestamp() =&gt; Updating last sync time for &quot; + sobj + &quot; with soupEntryId: &quot; + metadata._soupEntryId);
	var cacheMeta = metadata;
	cacheMeta.lastSync = time;
	var handleTimeSuccess = function(results) {
		&#x2F;&#x2F;logToConsole(&quot;OfflineQueue :: updateTimestamp() :: handleTimeSuccess() =&gt; successful update of time for &quot; + sobj);
		&#x2F;&#x2F;logToConsole(&quot;OfflineQueue :: updateTimestamp() :: handleTimeSuccess() =&gt; result: &quot; + JSON.stringify(results));
		if (callback != null)
			callback(results);
	}
	
	var handleTimeFail = function() {
		logToConsole(&quot;OfflineQueue :: updateTimestamp() :: handleTimeFail() =&gt; lastSync update failed &quot; + JSON.stringify(arguments));
		
	}
	navigator.smartstore.upsertSoupEntriesWithExternalId(&quot;Metadata&quot;, [cacheMeta], &quot;name&quot;, handleTimeSuccess, handleTimeFail);
}

&#x2F;**
 * Get single metadata objects from Metadata soup
 * @method getMetadataFromSoup
 * @param {String} objName
 * @param {Function} callback
 * @param {Function} errorHandler
 **&#x2F;
OfflineQueue.prototype.getMetadataFromSoup = function(objName, callback, errorHandler) {
	var querySpec;
	querySpec = navigator.smartstore.buildExactQuerySpec(&quot;name&quot;, objName, 10);
	
    navigator.smartstore.querySoup(&#x27;Metadata&#x27;,querySpec, function(cursor) {
		var records = [];
		
		if (cursor.currentPageOrderedEntries.length &gt; 0) {
			records = MMJSE_SmartStoreUtil.LoadAllRecords(cursor,records);
			logToConsole(&quot;OfflineQueue :: getMetadataFromSoup() =&gt; &quot;+ records.length + &quot; Soup results for &quot; + objName);
			&#x2F;&#x2F;logToConsole(JSON.stringify(records[0].lastSync));
			&#x2F;&#x2F;close the query cursor
			navigator.smartstore.closeCursor(cursor);
		}
		callback(objName, records);
    },errorHandler);
}

&#x2F;**
 * Get ALL metadata objects from Metadata soup
 * @method getAllMetadataFromSoup
 * @param {Array} expectedRecords
 * @param {Function} callback
 * @param {Function} errorHandler
 **&#x2F;
OfflineQueue.prototype.getAllMetadataFromSoup = function(expectedRecords, callback, errorHandler) {
	logToConsole(&quot;QUerying all metadata from soup&quot;);
	var querySpec;
	if (window.mmSync != null &amp;&amp; expectedRecords != null ) {
		querySpec = navigator.smartstore.buildAllQuerySpec(&quot;name&quot;, null, expectedRecords);
	}
	else {
		querySpec = navigator.smartstore.buildAllQuerySpec(&quot;name&quot;, null, 50);
	}
    navigator.smartstore.querySoup(&#x27;Metadata&#x27;,querySpec, function(cursor) { 
		callback(cursor);
    },errorHandler);
}

&#x2F;**
 * Get actual entries returned from soup via cursor
 * @method handleGetAllEntriesFromSoup
 * @param {Cursor} cursor
 **&#x2F;
OfflineQueue.prototype.handleGetAllEntriesFromSoup = function(cursor) {
	var entries = [];
	logToConsole(&quot;Returning all soup entries&quot;);
	var addEntriesFromCursor = function() {
		var curPageEntries = cursor.currentPageOrderedEntries;
		$j.each(curPageEntries, function(i,entry) {
			&#x2F;&#x2F;console.log(&quot;Entry is &quot; + entry.name + &quot; &quot; + entry.lastSync + &quot; &quot; + JSON.stringify(entry.metadataResponse));
			entries.push(entry);
		});
	}
	
	addEntriesFromCursor();
	
	while(cursor.currentPage &lt; cursor.totalPages - 1) {
		logToConsole(&quot;Cursor on page &quot; + cursor.currentPage);
		navigator.smartstore.moveCursorToNextPage(cursor, addEntriesFromCursor);
	}
	navigator.smartstore.closeCursor(cursor);
	return entries;
}

&#x2F;**
 * Take the array of objects passed in from json.sync and created soups for each
 * @method createObjectSoups
 * @param {Array&lt;SyncObject&gt;} syncObjects
 * @param {Function} callback
 * @param {Object} error
 **&#x2F;
OfflineQueue.prototype.createObjectSoups = function(syncObjects,callback,error) {
	logToConsole(&quot;Creating soups&quot;);
	this.objectSoupCount = 0;	
	this.objectCount = syncObjects.length;
	
	for (var s = 0; s &lt; syncObjects.length; s++) {
		var so = syncObjects[s];
		this.createObjectSoup(so, callback);
	}
	
}

&#x2F;**
 * Create soup for a particular Salesforce object based on json.sync settings
 * @method createObjectSoup
 * @param {Object} soupDetails
 * @param {Function} callback
 **&#x2F;
OfflineQueue.prototype.createObjectSoup = function(soupDetails,callback) {
	&#x2F;&#x2F;logToConsole(&quot;Calling createObjectSoup for &quot; + soupDetails.name);
	
	var offlineQueue = window.offlineQueue;
	if (typeof soupDetails.indexSpec == &#x27;undefined&#x27;) {;
		soupDetails.indexSpec = [
                {&quot;path&quot;:&quot;Id&quot;,&quot;type&quot;:&quot;string&quot;},
                {&quot;path&quot;:&quot;Name&quot;,&quot;type&quot;:&quot;string&quot;}
            ];
	}
	
	if (typeof navigator.smartstore != &#x27;undefined&#x27;) {
		
		navigator.smartstore.soupExists(soupDetails.name, function(param) {
			if (!param) {
				logToConsole(&quot;Registering soup for &quot; + soupDetails.name);
				if (soupDetails.indexSpec) {
					navigator.smartstore.registerSoup(soupDetails.name, soupDetails.indexSpec, function (param) {
						logToConsole(&#x27;Soup Created: &#x27; + param);
						offlineQueue.completeObjectSoup(soupDetails.name,callback);
					}, function (err) {
							offlineQueue.handleSoupCreateError(error,soupDetails.name);
					});
				}
				else {
					navigator.smartstore.registerSoup(soupDetails.name, soupDetails.indexSpec, function(param) {
						logToConsole(&#x27;Soup Created: &#x27; + param);
						offlineQueue.completeObjectSoup(soupDetails.name,callback);
					}, function (err) {
							offlineQueue.handleSoupCreateError(error,soupDetails.name);
					});
				}
			}
			else {
				logToConsole(&#x27;Soup Exists: &#x27;+ soupDetails.name);
				offlineQueue.completeObjectSoup(soupDetails.name,callback);
			}
		});
	}
	else {
		logToConsole(&quot;Smartstore does not exist inside of OfflineQueue&quot;);
	}
	
}

&#x2F;**
 * Increment total number of created soups and make callback if all sf object queues are creates
 * @method completeObjectSoup
 * @param {Object} completeObj
 * @param {Function} callback
 *&#x2F;
OfflineQueue.prototype.completeObjectSoup = function (completeObj, callback) {
	logToConsole(&quot;OfflineQueue :: completeObjectSoup() called for &quot; + completeObj);
	
	this.objectSoupCount++;
	if (this.objectSoupCount == this.objectCount) {
		if (typeof callback != &#x27;undefined&#x27;) {
			logToConsole(&quot;All soups created or exist, making passed callback&quot;);
			callback();
		}
		else {
			logToConsole(&quot;All soups created&quot;);
		}
	}
	
	
}

&#x2F;**
 * Log error if creation of a soup occurs
 * @method handleSoupCreateError
 * @protected
 * @param {Object} e
 * @param {String} soupName
 *&#x2F;
OfflineQueue.prototype.handleSoupCreateError = function(e, soupName) {
	if (soupName) {
		logToConsole(&#x27;Error creating &#x27; + soupName + &#x27;  soup in smartstore: &#x27; + JSON.stringify(e));
	}
	else {
		logToConsole(&#x27;Error creating soup in smartstore: &#x27; + JSON.stringify(e));
	}
}

&#x2F;**
 * Write records to local smartstore soup
 * @method cacheToLocal
 * @param {Object} sobj
 * @param {Array} records
 * @param {Function} callbackSuccess
 * @param {Function} callbackFail
 *&#x2F;
OfflineQueue.prototype.cacheToLocal = function(sobj, records, callbackSuccess, callbackFail) {
	logToConsole(&quot;Caching results for &quot; + sobj);
	navigator.smartstore.upsertSoupEntriesWithExternalId(sobj, records, &quot;Id&quot;, callbackSuccess, callbackFail);
}

&#x2F;**
 * Check the queue record whether the queue record has to be upserted or deleted\
 * @method checkIfQueueIsForDelete
 * @param {Object} QueueRecord
 * @return true&#x2F;false
*&#x2F;
OfflineQueue.checkIfQueueIsForDelete = function(QueueRecord){
    logToConsole(&#x27;OfflineQueue.checkIfQueueIsForDelete&#x27;);
    var queueOperation = QueueRecord.Operation;
    if(queueOperation == &#x27;delete&#x27;){
        return true;
    }
    return false;
    &#x2F;&#x2F;Return true&#x2F;false based on queue record
}

&#x2F;**
 * Delete the record from SFDC based on queue record Id and sync.json settings
 * @method runSFDCDeleteQuery
 * @param {Object} QueueRecord
 * @param {Function} callback
 * @param {Function} onError
 *&#x2F;
OfflineQueue.runSFDCDeleteQuery = function(QueueRecord, callback, onError){
    logToConsole(&#x27;OfflineQueue.runSFDCDeleteQuery&#x27;);
    var mmSync = window.mmSync;
    
    var SOName = QueueRecord.attributes.type;
    var SOId = QueueRecord.Id;
    var _soupEntryId = QueueRecord._soupEntryId;

    &#x2F;&#x2F;Extract the id of the record from QueueRecord and call forcetk del method
    forcetkClient.del(SOName,SOId,function(){
         console.log(&#x27;QUEUED SFDC Delete Success!&#x27;);
         
         navigator.smartstore.removeFromSoup(&#x27;Queue&#x27;,[_soupEntryId],function(s){
             console.log(&#x27;Removed from Soup&#x27;);
           	 callback();
         },mmSync.handleErrorSFDC);
     },mmSync.handleErrorSFDC);
}

&#x2F;**
 *  Delete the record from SFDC based on queue record Id and sync.json settings using batch processing
 *  @method runSFDCDeleteQueryUsingBatch
 *  @param {Array} deleteRecordsArray
 *  @param {Function} callback
 *  @param {Function} errorCallback
 *&#x2F;
OfflineQueue.runSFDCDeleteQueryUsingBatch = function(deleteRecordsArray, callback, errorCallback){
    logToConsole(&#x27;OfflineQueue.runSFDCDeleteQueryUsingBatch: &#x27;+JSON.stringify(deleteRecordsArray));
    var mmSync = window.mmSync;
    var recordIdsToDelete = new Array();
    var _soupEntryIdToDelete = new Array();
    for (var x = 0; x &lt; deleteRecordsArray.length; x++){
        recordIdsToDelete.push(deleteRecordsArray[x].Id);
    }
    console.log(&quot;recordIdsToDelete: &quot; + recordIdsToDelete + &quot; _soupEntryIdToDelete:: &quot;+ _soupEntryIdToDelete);
    var SOName = deleteRecordsArray[0].attributes.type;
    var onError = function(error) {
		if (typeof errorCallback != &quot;undefined&quot;) {
			errorCallback(error);
		}
		else {
			mmSync.handleErrorSFDC(error);
		}
	}
    
	logToConsole(&quot;Deleting from salesforce via batch&quot;);
    window.soapClient.deleteIds(recordIdsToDelete, function(response) {
		logToConsole(&quot;Batch SFDC Delete response &quot; + JSON.stringify(response));
		&#x2F;&#x2F; Delete from smartstore Queue soup on success
		var queueDeleteSoupIds = [];
		var responseIds;
		for (var d = 0; d &lt; response.length; d++) {
			if (eval(response[d].success)) {
				queueDeleteSoupIds.push(deleteRecordsArray[d]._soupEntryId);
			}
			else {
				onError(&quot;Salesforce error deleting record: &quot; + JSON.stringify(response[d]));
			}
		}
		if (queueDeleteSoupIds.length &gt; 0) {
			navigator.smartstore.removeFromSoup(&#x27;Queue&#x27;,queueDeleteSoupIds,function(s){
				logToConsole(&#x27;Records removed from Queue soup&#x27;);
				if (typeof callback != &quot;undefined&quot;) {
					callback();
				}
				else {
					mmSync.handleErrorSFDC(&quot;Error: No callback defined&quot;);
				}
				
			},onError);
		}
		else {
			logToConsole(&quot;No successful SFDC deletes to remove from soups&quot;);
		}
		
	});
   
   
}


&#x2F;**
 * Delete the record from it&#x27;s Object soup then call StoreReocrd to save delete to Queue and if online, remove from SFDC
 * @method deleteFromObjectSoup
 * @param {Object} jsonObj
 * @param {Function} callback
 * @param {Function} onError
 *&#x2F;
OfflineQueue.deleteFromObjectSoup = function (jsonObj, callback, onError) {
	var objName = jsonObj.attributes.type;
	navigator.smartstore.removeFromSoup(objName,[jsonObj._soupEntryId],function(s){
		jsonObj.Operation = &#x27;delete&#x27;;
		jsonObj.SObjectType = jsonObj.attributes.type;
		OfflineQueue.StoreRecords([jsonObj],callback,onError);
	},onError);
}


&#x2F;**
 * Upsert to SFDC based on queue record Id and sync.json settings
 * @method runSFDCUpsertQuery
 * @param {Object} queueRecord
 * @param {Array&lt;Object&gt;} syncJsonObjs
 * @param {Function} callback
 * @param {Function} errorCallback
 *&#x2F;
OfflineQueue.runSFDCUpsertQuery = function(QueueRecord, syncJsonObjs, callback, errorCallback){
    logToConsole(&#x27;OfflineQueue.runSFDCUpsertQuery&#x27;);
    
    var mmSync = window.mmSync;
    var SOName = QueueRecord.attributes.type;
    var SOId = QueueRecord.Id;
    var _soupEntryId = QueueRecord._soupEntryId;
    var fieldQueryString = OfflineQueue.buildFieldQuery(QueueRecord, syncJsonObjs);
    var fieldQueryStringObj = eval(&#x27;(&#x27; + fieldQueryString + &#x27;)&#x27;);
	var onError = function(error) {
		if (errorCallback != null) {
			errorCallback(error);
		}
		else {
			mmSync.handleErrorSFDC(error);
		}
		
	}
    &#x2F;&#x2F;logToConsole(SOName+&#x27; : &#x27;+SOId+&#x27; : &#x27;+JSON.stringify(fieldQueryStringObj));
    mmSync.forcetkClient.upsert(SOName, &quot;Id&quot;, SOId, fieldQueryStringObj, function(response){
                 logToConsole(&#x27;QUEUED SFDC single record Update Success! &#x27; + JSON.stringify(response));				 
				 &#x2F;* TODO JE: Commented out until work on US74
				 if (objQueueRecord.Id == null) {
					 &#x2F;&#x2F;upsert record to smartstore with returned ID from salesforce upsert
					  objQueueRecord.Id == response.id;
					  navigator.smartstore.upsertSoupEntries(SOName, [objQueueRecord], function(result){
						
						&#x2F;&#x2F;remove from Queue soup after smart store object update is complete and make callback
						 navigator.smartstore.removeFromSoup(&#x27;Queue&#x27;,[_soupEntryId],function(){
							 logToConsole(&#x27;Removed from Soup after local update to new object&#x27;);
							 callback();
						 },onError);&#x2F;&#x2F; end : removeFromSoup 
					 }, error);
					  
				 }
				 else {
					 &#x2F;&#x2F;remove from Queue soup if object was not an update
				*&#x2F;
					 navigator.smartstore.removeFromSoup(&#x27;Queue&#x27;,[_soupEntryId],function(){
						 logToConsole(&#x27;Removed from Soup&#x27;);
						 callback();
					 },onError);&#x2F;&#x2F; end : removeFromSoup 
				 &#x2F;* TODO JE: Commented out until work on US74 
				 }
				 *&#x2F;
				
         }, onError);
}

&#x2F;**
 * Upsert to SFDC based on queue record Id and sync.json settings using batch processing
 * @method runSFDCUpsertQueryUsingBatch
 * @param {Array&lt;Object&gt;} upsertRecordsArray
 * @param {Array&lt;Object&gt;} syncJsonObjs
 * @param {Function} callback
 *&#x2F;
OfflineQueue.runSFDCUpsertQueryUsingBatch = function(upsertRecordsArray, syncJsonObjs, callback, onError){
    logToConsole(&#x27;OfflineQueue.runSFDCUpsertQueryUsingBatch&#x27;);
    
    var mmSync = window.mmSync;
    var recordsToUpsert = new Array();
    var _soupEntryIdToDelete = new Array();
    for(var x = 0; x &lt; upsertRecordsArray.length; x++){
        _soupEntryIdToDelete.push(upsertRecordsArray[x]._soupEntryId);
    }
	
	if (onError == null) {
		onError = function(error) {
			mmSync.handleErrorSFDC(error);
		}
	}

    console.log(&quot;Before SFDC upsert of &quot; + upsertRecordsArray[0].attributes.type);
	
    var fieldQueryString = OfflineQueue.buildFieldQueryForBatch(upsertRecordsArray, syncJsonObjs);
    &#x2F;&#x2F;****TODO: Call soap client, and on response remove from soup in callback instead of inline, call is async so we&#x27;re removing from soup even if failure occurs
    window.soapClient.upsert(&quot;Id&quot;, fieldQueryString, function(result) {
		if(result[0].getBoolean(&quot;success&quot;)) {
			console.log(&quot;upsert success&quot;);
			console.log(&quot;After upserting the data&quot;);
    
			navigator.smartstore.removeFromSoup(&#x27;Queue&#x27;,_soupEntryIdToDelete,function(s){
				callback();
			},onError);
		}else {
			console.log(&quot;upsert failed! &quot;+result);
		}
		
	});
    
   
}

&#x2F;**
 *  Builds Field Query for Batches
 *  @method buildFieldQueryForBatch
 *  @protected
 *  @param {Array&lt;Object&gt;} queueRecords
 *  @param {Array&lt;Object&gt;} syncJsonObjs
**&#x2F;
OfflineQueue.buildFieldQueryForBatch = function(QueueRecords, syncJsonObjs){
    logToConsole(&quot;OfflineQueue.buildFieldQueryForBatch&quot;);
    var mmSync = window.mmSync;
    var SObjectName = QueueRecords[0].attributes.type;
    
    for(var soCount = 0; soCount &lt; syncJsonObjs.length; soCount++ ){
        if(SObjectName == syncJsonObjs[soCount].name){
            var syncJsonObj = syncJsonObjs[soCount];
            var fields = syncJsonObj.fields;
        }
    }
    
    var recordsToUpsert = {};
    var fieldQueryString = new Array();
    if (fields) {
        for(var x = 0; x &lt; QueueRecords.length; x++){
            var QueueRecord = QueueRecords[x];
            var SObjectType = QueueRecord.attributes.type;
            SObject_1 = new sforce.SObject(SObjectType);

            for (var f=0; f &lt; fields.length; f++) {
                SObject_1[fields[f]] = QueueRecord[fields[f]];
            }
            fieldQueryString.push(SObject_1);
        }
	}else{
		var objFields = mmSync.objectsMetadata[SObjectName].metadataResponse.fields; &#x2F;&#x2F; if mmSync returns error then objectMetaData wont be available.
        logToConsole(objFields.length);
        for(var x = 0; x &lt; QueueRecords.length; x++){
            var QueueRecord = QueueRecords[x];
            var SObjectType = QueueRecord.attributes.type;
            SObject_1 = new sforce.SObject(SObjectType);
            
            for (var f=0;f &lt; objFields.length; f++) {
                var field = objFields[f];
                var fieldName = field.name;
                var isUpdateable = field.updateable;
                if(isUpdateable || fieldName == &quot;Id&quot;){
                    if (typeof syncJsonObj.ignorefields == &quot;undefined&quot; || syncJsonObj.ignorefields == null) {
                        SObject_1[fieldName] = QueueRecord[fieldName];
                    }else{
                        var ignoreThis = mmSync.checkIgnoreField(syncJsonObj,fieldName);
                        if (!ignoreThis) {
                            SObject_1[fieldName] = QueueRecord[fieldName];
                        }
                    }
                }
            }
            console.log(&quot;SObject_1:- &quot;+SObject_1);
            fieldQueryString.push(SObject_1);
        }
	}
    
    return fieldQueryString;    
}

&#x2F;**
 * This is method will return the fields to be upserted in field:value format based on sync.json settings
 * @method buildFieldQuery
 * @protected
 * @param {Object} queueRecord
 * @param {Array&lt;Object&gt;} syncJsonObjs
 *&#x2F;
OfflineQueue.buildFieldQuery = function(QueueRecord, syncJsonObjs){
    logToConsole(&quot;OfflineQueue.buildFieldQuery&quot;);
  
    var mmSync = window.mmSync;
    var SObjectName = QueueRecord.attributes.type;
    for(var soCount = 0; soCount &lt; syncJsonObjs.length; soCount++ ){
        if(SObjectName == syncJsonObjs[soCount].name){
            var syncJsonObj = syncJsonObjs[soCount];
            var fields = syncJsonObj.fields;
        }
    }
    
    var fieldQueryString = &quot;{&quot;;
    if (fields) {
		for (var f=0; f &lt; fields.length; f++) {
            if(fields[f] != &quot;Id&quot;){
                fieldQueryString += &#x27;&quot;&#x27; + fields[f] + &#x27;&quot;&#x27; + &#x27;:&quot;&#x27; + QueueRecord[fields[f]] + &#x27;&quot;,&#x27;;
            }
		}
     	fieldQueryString = fieldQueryString.slice(0,-1);
	}
	else {
		var objFields = mmSync.objectsMetadata[SObjectName].metadataResponse.fields; &#x2F;&#x2F; if mmSync returns error then objectMetaData wont be available.
        
        for (var f=0;f &lt; objFields.length; f++) {
			var field = objFields[f];
            var isUpdateable = field.updateable;
			if(isUpdateable){
                if (typeof syncJsonObj.ignorefields == &quot;undefined&quot; || syncJsonObj.ignorefields == null) {
                    var fieldName = field.name;
                    if(!!QueueRecord[fieldName])fieldQueryString += &quot;&#x27;&quot; + fieldName + &quot;&#x27;&quot; + &quot;:&#x27;&quot; + QueueRecord[fieldName] + &quot;&#x27;,&quot;;
                }
                else {
                    var fieldName = field.name;
                    var ignoreThis = mmSync.checkIgnoreField(syncJsonObj,fieldName);
                    if (!ignoreThis) {
                        if(!!QueueRecord[fieldName])fieldQueryString += &quot;&#x27;&quot; + fieldName + &quot;&#x27;&quot; + &quot;:&#x27;&quot; + QueueRecord[fieldName] + &quot;&#x27;,&quot;;
                    }
                }
            }
		}
		fieldQueryString = fieldQueryString.slice(0,-1);
		logToConsole(&quot;Fields list in field:value format for &quot; + syncJsonObj.name +&quot;: &quot; + fieldQueryString);
	}    
    fieldQueryString = fieldQueryString + &quot;}&quot;;
    return fieldQueryString;
}

&#x2F;**
 * CREATE DESCRIPTION
 * @method enqueueRecords
 * @note : this function may not be needed
 * @todo : if not used remove it
 * @param {Array&lt;Object&gt;} records
 * @param {Function} successCB
 * @param {Function} errorCB
 *&#x2F;
OfflineQueue.prototype.enqueueRecords = function(records, successCB, errorCB){
    logToConsole(&#x27;OfflineQueue.enqueueRecords&#x27;);
    var offlinequeue = this;
    navigator.smartstore.soupExists(&#x27;Queue&#x27;,function(param){
                                if(param){
                                    if(!!navigator.smartstore){
                                        logToConsole(&quot;write to soup : inside if condition&quot;);
                                        $j.each(records, function(index,value) {
                                            logToConsole(&quot;record &quot;+index+&quot;: &quot;+JSON.stringify(value));
                                        });
                                        navigator.smartstore.upsertSoupEntries(&#x27;Queue&#x27;,records, successCB, errorCB);
                                    }
                                    
                                }
                                else{
                                    logToConsole(&#x27;Queue soup does not exists &#x27;);
                                    offlinequeue.RegisterQueueSoup();
                                    }
                                }
                                ,error);
};

&#x2F;**
 *  CREATE DESCRIPTION
 *  @method fetchObjectList
 *  @param {String} objectName
 *  @param {Integer} pageSize
 *  @param {Function} callback
 *  @param {Function} errorCallback
**&#x2F;
OfflineQueue.prototype.fetchObjectList = function(objectName, pageSize, callback, errorCallback) {
	$j.blockUI({message:&quot;Fetching &quot; + objectName + &quot; list from SmartStore&quot;,onBlock:function() {
			setTimeout(function() {
				var querySpec = navigator.smartstore.buildAllQuerySpec(&quot;Id&quot;, null, pageSize);
				&#x2F;&#x2F;logToConsole(&#x27;Query spec for smart store contacts -- &#x27;+JSON.stringify(querySpec));
				navigator.smartstore.soupExists(objectName,
					function(param){ &#x2F;&#x2F; success handler
						if(param){
							navigator.smartstore.querySoup(objectName, querySpec,callback, errorCallback); &#x2F;&#x2F; end : query smart store contacts
						}
						else{
							$j.unblockUI();
							logToConsole(objectName + &#x27; soup does not exist&#x27;);
						}
					},
					function(error) { &#x2F;&#x2F; error handler
						logToConsole(&quot;Error with soup exists &quot; + JSON.stringify(error));
					}
				);
			});
		}
	});	
}


&#x2F;**
* MMSync engine
* @module MM_JSSyncEngine
* @class MMSync
* @constructor
* @requires jQuery 1.2.3 or later, jquery.blockUI plugin, Salesforce forceTk, OfflineQueue, sync.json
**&#x2F;

function MMSync () {
	this.SYNC_COMPLETE = &#x27;sync_complete&#x27;;
	this.network;	
	this.statusScreen;
	this.arraySyncObjects = [];
	this.hashSyncObjects = {}; &#x2F;&#x2F; keyed on object name from sync.json file parsing	
	this.forcetkClient;
	this.syncTime = new Object(); &#x2F;&#x2F; keyed on object name
	
	this.objectsMetadata = {};
	this.lastSyncs = {}; &#x2F;&#x2F;Hash keyed on object name
	
	this.syncObjectCount = 0;
	this.describeCompleteCount = 0;
	this.syncRecordCounts = {};
	
	this.queryCursorCount = 10;
	this.useQueryCursorCount = false;

	this.onJSON_Loaded = null;
	this.offlineQueue;
	
	&#x2F;&#x2F;-- the following line is the version of the MM SYNC and will be updated by code
	&#x2F;&#x2F;-- please do not remove these quotes
	&#x2F;&#x2F;-- MM_SYNCH_VERSION
	this.version=&#x27;1.0.0a&#x27;;
	
   &#x2F;&#x2F; this.initialize();
}

&#x2F;**
 * Initialize Model Metrics Synchronization Engine
 * @method initialize
 * @param forceResync
 **&#x2F;
MMSync.prototype.initialize = function(forceResync) {
	
	window.logToConsole(&#x27;Initializing MMSync&#x27;);
	if (window.forcetkClient)
		this.forcetkClient = window.forcetkClient;
	
	this.network = new Network();
	this.network.callbackOnline = function() { console.log(&quot;Network has gone online&quot;) };
	this.network.callbackOffline = function() {  console.log(&quot;Network has gone offline&quot;) };	
	
	&#x2F;&#x2F;Define new offlineQueue
	if (typeof window.offlineQueue == &#x27;undefined&#x27;) {
		logToConsole(&quot;Offline queue created&quot;);
		this.offlineQueue = new OfflineQueue();
		
	}
	else {
		logToConsole(&quot;Offline queue assigned to window.offlineQueue&quot;);
		this.offlineQueue = window.offlineQueue;
	}
	this.statusScreen = new views.StatusScreen(); &#x2F;&#x2F; Initialize status screen
	if ((forceResync != null &amp;&amp; forceResync ==true) || this.syncObjectCount == 0 || this.syncObjectCount &lt; this.arraySyncObjects.length) {
		this.readSyncJSON(); &#x2F;&#x2F; LOAD json.sync values
	}
	
}


&#x2F;**
 * Read&#x2F;set sync JSON and kick off creation of Metadata queue soupd and smartstore Object soups
 * @method readSyncJSON
 **&#x2F;
MMSync.prototype.readSyncJSON = function() {	
	this.arraySyncObjects = window.syncJSON.objects;
	this.syncObjectCount = 0;
	this.describeCompleteCount = 0;
	this.queryCursorCount = 10;
	this.useQueryCursorCount = false;
	this.lastSyncs = {};
	this.objectsMetadata = {};
	
	var mmSync = this;
	
	if( this.onJSON_Loaded != null ){
		this.onJSON_Loaded();
	}
	
	&#x2F;&#x2F; Generate MetaData soup in SmartStore, Queue soup,  and individual object soups once JSON config is read
	if (typeof this.offlineQueue != &#x27;undefined&#x27;) {
		if (typeof PhoneGap != &#x27;undefined&#x27; &amp;&amp; this.hasSmartstore) {
			var metaCallback = function() {
				window.logToConsole(&quot;Createing sobject soups&quot;);
				mmSync.offlineQueue.createObjectSoups(mmSync.arraySyncObjects, mmSync.handleSoupsCreated);
			}
			
			var queueCallback = function() {
				logToConsole(&quot;Creating metadata soup&quot;);
				this.offlineQueue.createMetadataSoup(metaCallback);
			}
			
			logToConsole(&quot;Creating Queue soup&quot;);
			OfflineQueue.RegisterQueueSoup(queueCallback);
			
			
			
		}
		else {
			alert(&quot;No soups for you! This application requires Salesforce smartstore&quot;);
			&#x2F;&#x2F;createmetaData();
		}
	}
	else {
		logToConsole(&quot;offlineQueue does not exist&quot;);
	}	
	
}

&#x2F;**
 * Check to see if phonegap smartstore plugin is available
 * @method hasSmartstore
 **&#x2F;
MMSync.prototype.hasSmartstore = function () {
	if (PhoneGap.hasResource(&quot;smartstore&quot;) &amp;&amp; typeof navigator.smartstore != &#x27;undefined&#x27;) {
		return true;
	}
	return false;
}


&#x2F;**
 * Handler for once all soups are created or are determined to already exist. Starts actual synchronization process if online.
 * @protected
 * @method handleSoupsCreated
 **&#x2F;
MMSync.prototype.handleSoupsCreated = function() {	
	logToConsole(&quot;Soups created.&quot;);
	var mmSync = window.mmSync;
	
	if (mmSync.network.isConnected) {
		&#x2F;&#x2F; Call salesforce describe for each object
		$j.blockUI({message:&quot;Loading metadata for Salesforce objects&quot;,
			onBlock:function() {
				for (var o=0;o &lt; mmSync.arraySyncObjects.length;o++) {
				var objName = mmSync.arraySyncObjects[o].name;
				logToConsole(&quot;Caling describe for &quot; + objName);
				mmSync.forcetkClient.describe(objName, mmSync.handleDescribeResponse,
					function(error) {
						logToConsole(&quot;Error with descibe for &quot; + objName);
						mmSync.handleErrorSFDC(error);
					});
				}		
			}
		});
		
	}
	else {
		&#x2F;&#x2F;TODO: Start offline initialization
	}
}

&#x2F;**
 * Handler for response from forceTK describe calls. Calls sync if all describes are complete to request data.
 * @protected
 * @method handleDescribeResponse
 * @param response
 **&#x2F;
MMSync.prototype.handleDescribeResponse = function(response) {
	var mmSync = window.mmSync;
	
	logToConsole(&quot;Describe returned for &quot; + response.name);
	mmSync.objectsMetadata[response.name] = new vo.MetadataVO(response.name, response);
	
	var cacheMetaSuccess = function() {
		mmSync.describeCompleteCount++;
		if (mmSync.describeCompleteCount &gt;= mmSync.arraySyncObjects.length) {
			$j.unblockUI();
			try {
				&#x2F;&#x2F; Start upstream and downstream full sync process
				mmSync.doFullSync();
			}
			catch (e) {
				logToConsole(&quot;Error calling sync: &quot; + e);
			}
		}
	}
	
	var cacheMetaError = function() {
		logToConsole(&quot;Error cacheing metadata response to smartstore soup&quot;);
	}
	
	var getMetadataSoupId = function(objName, results) {
		&#x2F;&#x2F;logToConsole(&quot;MMSync :: getMetadataSoupId :: Metadata returned for &quot; + objName + &quot; setting SoupId &#x2F; Results: &quot; + JSON.stringify(results));
		if (results.length &gt; 0) {
			&#x2F;&#x2F;Expecting only a single result for an object
			mmSync.objectsMetadata[objName] = results[0];
			&#x2F;&#x2F;mmSync.objectsMetadata[objName].lastSync = results[0].lastSync;
		}
		&#x2F;&#x2F;cache latest metadata for SF object
		mmSync.offlineQueue.cacheMetadata(objName, mmSync.objectsMetadata[objName], cacheMetaSuccess, cacheMetaError);
	}
	
	var getMetadataSoupIdError = function() {
		logToConsole(&quot;Error getting meta soup id&quot;);
	}
	&#x2F;&#x2F;Check to see if metaData exists in soup already and retrieve soupEntryId before upsert
	mmSync.offlineQueue.getMetadataFromSoup(response.name, getMetadataSoupId, error);	
}

MMSync.prototype.doFullSync = function() {
	var mmSync = window.mmSync;
	mmSync.syncUp(function() {
		&#x2F;&#x2F; get lastSync times from Metadata soup, on completion call syncDown to
		&#x2F;&#x2F; pull new&#x2F;updated records from Salesforce
		var handleGetLastUpdatesResponse = mmSync.syncDown;
		mmSync.getLastUpdates(handleGetLastUpdatesResponse);
	});	
}

&#x2F;**
* Runs OfflineQueue method to push all local data to Salesforce.com based on json.sync.objects definitions
* callback is required
**&#x2F;
MMSync.prototype.syncUp = function(callback) {
	var handleUploadSuccess = function() {
		$j.unblockUI();
	}
	
	$j.blockUI({
		message:&quot;Pushing local changes to Salesforce&quot;, 
		onBlock:function() {
			logToConsole(&#x27;Calling uploadQueue&#x27;);
			OfflineQueue.UploadQueue(handleUploadSuccess,mmSync.handleErrorSFDC);
		},
		onUnblock:function() {
			callback();
		}
	});
		
}

&#x2F;**
* Builds sync status screen based on json.sync.objects definitions then pulls data from 
* Salesforce.com based on json.sync.objects definitions
* callback is optional
* @method sync
**&#x2F;
MMSync.prototype.syncDown = function(callback) {
	logToConsole(&quot;sync started&quot;);
	
	var statusHTML;
	var mmSync = window.mmSync;
	
	if (typeof mmSync.statusScreen != &#x27;undefined&#x27; &amp;&amp; mmSync.statusScreen != null) {
		statusHTML = mmSync.statusScreen.buildSyncScreen(mmSync.arraySyncObjects);
	}
	else {
		mmSync.statusScreen = new views.StatusScreen();
		statusHTML = mmSync.statusScreen.buildSyncScreen(mmSync.arraySyncObjects);
	}
	mmSync.statusScreen.showStatus(statusHTML);

	&#x2F;&#x2F;TODOL: Start upload for each object if lastSync is available then sync&#x2F;query each object, otherwise just query each object
	&#x2F;&#x2F;logToConsole(&#x27;calling uploadQueue&#x27;);
	&#x2F;&#x2F;mmSync.uploadQueue();
	var so;
	if (mmSync.arraySyncObjects.length &lt; 10) {
		mmSync.useQueryCursorCount = false;
		for (var s=0; s &lt; mmSync.arraySyncObjects.length; s++) {
			so = mmSync.arraySyncObjects[s];
			mmSync.syncObject(so);
		}
	}
	else {
		mmSync.useQueryCursorCount = true;
		for (var s=0; s &lt; 10; s++) {
			so = mmSync.arraySyncObjects[s];
			mmSync.syncObject(so);
		}
	}
}

&#x2F;**
 *  Syncs an object
 *  @method syncObject
 *  @param {SyncObject} so - sync.json SyncObject
**&#x2F;
MMSync.prototype.syncObject = function(so) {
	var mmSync = window.mmSync;
	logToConsole(&quot;MMSync :: syncDown() =&gt; Calling mmSync.buildQuery() for &quot; + so.name);
	var queryString = mmSync.buildQuery(so);
	
	try {
		mmSync.forcetkClient.query(queryString,
			function(response,textStatus,jqXHR) {
				logToConsole(&quot;MMSync :: syncDown() :: query Response :: Response from: &quot; + so.name);
				var objName = so.name;

				&#x2F;&#x2F;set sync time
				var timeStamp = jqXHR.getResponseHeader(&#x27;Date&#x27;);
				window.logToConsole(objName + &#x27; Query Time: &#x27;+ timeStamp);
				mmSync.syncTime[objName] = new Date(timeStamp);
	
				if (so.donotcache != &#x27;undefined&#x27;) {
					mmSync.handleSyncObjectResult(response,so.name,so.donotcache);
				}
				else {
					mmSync.handleSyncObjectResult(response,so.name, false);	
				}
		}, mmSync.handleErrorSFDC); 
	}
	catch (e) {
		logToConsole(&quot;Error querying &quot; + so.name + JSON.stringify(e));
	}
}

&#x2F;**
 * Get last updates from Metadata soup if available
 * @method getLastUpdates
 * @param {function} callback
 **&#x2F;
MMSync.prototype.getLastUpdates = function(callback) {
	var mmSync = window.mmSync;
	
	var getLastSyncCallback = function(cursor) {		
		var metaEntries = mmSync.offlineQueue.handleGetAllEntriesFromSoup(cursor);
		&#x2F;&#x2F;logToConsole(&quot;MMSync :: getLastUpdates() :: getLastSyncCallback() =&gt; metaEntries: &quot; + JSON.stringify(metaEntries));
		for (var m=0;m &lt; metaEntries.length;m++) {
			var meta = metaEntries[m];
			if (typeof mmSync.objectsMetadata[meta.name] != &quot;undefined&quot;) {
				mmSync.objectsMetadata[meta.name]._soupEntryId = meta._soupEntryId;
			}
			if (typeof mmSync.objectsMetadata[meta.name] != &quot;undefined&quot; &amp;&amp; typeof meta.lastSync != &quot;undefined&quot; &amp;&amp; meta.lastSync != null) {
				logToConsole(&quot;MMSync :: getLastUpdates() :: getLastSyncCallback() =&gt; Last sync found for &quot; + meta.name);
				mmSync.objectsMetadata[meta.name].lastSync = new Date(meta.lastSync);
			}
		}
		callback();
	}
	var expectedRecords = mmSync.arraySyncObjects.length;
	mmSync.offlineQueue.getAllMetadataFromSoup(expectedRecords, getLastSyncCallback, mmSync.handleMetaSoupError);
	
}

&#x2F;**
 *  Handler for meta soup errors
 *  @protected
 *  @method handleMetaSoupError
 *  @param error
**&#x2F;
MMSync.prototype.handleMetaSoupError = function(error) {
	logToConsole(&quot;Error getting meta soup objects &quot; + JSON.stringify(error));
}

&#x2F;**
 * Build SOQL query string for so (sync object) param pulled from json.sync
 * @method buildQuery
 * @param {SyncObject} so - Sync object param pulled from json.sync
 **&#x2F;
MMSync.prototype.buildQuery = function(so) {
	logToConsole(&quot;MMSync :: buildQuery() =&gt; Building query for &quot; + so.name);
	var mmSync = window.mmSync;
	var queryString = &quot;SELECT Id,&quot;;
	if (typeof so.fields != &quot;undefined&quot;) {
		for (var f=0; f &lt; so.fields.length; f++) {
			if (so.fields[f] != &quot;Id&quot;) {
				queryString += so.fields[f] + &quot;,&quot;;
			}
		}
		queryString = queryString.slice(0,-1);
	}
	else {
		
		var objFields = mmSync.objectsMetadata[so.name].metadataResponse.fields;
		for (var f=0;f &lt; objFields.length; f++) {
			var field = objFields[f];
			
			if (field.name != &quot;Id&quot;) {
				if (typeof so.ignorefields == &quot;undefined&quot; || so.ignorefields == null) {
					logToConsole(&quot;Adding field &quot; + field.name + &quot; to &quot; + so.name + &quot; query&quot;);
					queryString += field.name + &quot;,&quot;;
				}
				else {
					var ignoreThis = mmSync.checkIgnoreField(so,field.name);
					if (!ignoreThis) {
						queryString += field.name + &quot;,&quot;;
					}
				}	
			}
		}
		queryString = queryString.slice(0,-1);
		&#x2F;&#x2F;logToConsole(&quot;MMSync :: buildQuery() =&gt; Field query portion from object without specified fields list for &quot; + so.name +&quot;: &quot; + queryString);
	}
	queryString += &quot; FROM &quot; + so.name;
	var objLastSync;
	if (typeof mmSync.objectsMetadata[so.name] != &quot;undefined&quot; &amp;&amp; typeof mmSync.objectsMetadata[so.name].lastSync != &quot;undefined&quot;) 
		objLastSync = mmSync.objectsMetadata[so.name].lastSync;
		
	if (objLastSync != null) {
		&#x2F;&#x2F;GET LAST UPDATE for object type and add here
		logToConsole(&quot;MMSync :: buildQuery() =&gt; objLastSync for &quot; + so.name + &quot; is &quot; + objLastSync);		
		var dateString = Util.dateTimeToUTCString(new Date(objLastSync));
        &#x2F;&#x2F;dateString = dateString.substring(0, 19)+&#x27;Z&#x27;;
		logToConsole(&quot;MMSync :: buildQuery() =&gt; dateString for &quot; + so.name + &quot; is &quot; + dateString);
		queryString += &quot; WHERE SystemModstamp &gt; &quot; + dateString + &quot; &quot;;
	}
	
	if (objLastSync == null &amp;&amp; so.hasOwnProperty(&quot;filter&quot;)) {
		queryString += &quot; WHERE &quot;;	
	}
	else if (objLastSync != null &amp;&amp; so.hasOwnProperty(&quot;filter&quot;)) {
		queryString += &quot; AND &quot;;	
	}
	
	if (so.hasOwnProperty(&quot;filter&quot;)) {
		queryString += so.filter;
	}
	if (so.hasOwnProperty(&quot;limit&quot;)) {
		queryString += &quot; LIMIT &quot; + so.limit;
	}
	return queryString;

}

&#x2F;**
 * Check to see if field is in the sync object&#x27;s ignore list
 * @method checkIgnoreField
 * @param {SyncObject} so - sync object from sync.json
 * @param {String} fieldName - fieldName to check
 **&#x2F;
MMSync.prototype.checkIgnoreField = function(so, fieldName) {
	&#x2F;&#x2F;logToConsole(&quot;MMSync :: checkIgnoreField() =&gt; Checking ignore fields for &quot; + so.name + &quot; field: &quot; + fieldName);
	for (var i = 0; i &lt; so.ignorefields.length; i++) {
		if (so.ignorefields[i] == fieldName) {
			return true;
		}
	}
	return false;
}

&#x2F;**
 * Response handler for Salesforce sobject query. 
 * Checks to see if more objects need to be retrieved and calls appropriate url if needed.
 * Makes call for each result set to cache to local database&#x2F;smarstore soup
 * Makes call to check if all data synchronization is complete.
 * @protected
 * @method handleSyncObjectResult
 * @param response
 * @param objName
 * @param nocache
 **&#x2F;
MMSync.prototype.handleSyncObjectResult = function(response,objName,nocache) {
	var mmSync = window.mmSync;
	&#x2F;&#x2F;TODO JE: fix objName being passed from query method
	var thisObj = objName;
	if (typeof response.records != &quot;undefined&quot; &amp;&amp; response.records.length &gt; 0) {
		if (objName != response.records[0].attributes.type) {
			thisObj = response.records[0].attributes.type;
			logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt; Object type is actually &quot; + thisObj);
		}
		
		&#x2F;&#x2F; Define success callback for cacheing of object to smartstore
		var cacheSuccess = function() {
			var mmSync = window.mmSync;
			logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt;  Cache complete for object &quot; + thisObj + &quot; iteration&quot;);
			if (response.done == true) {
				logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt; Cache complete for object &quot; + thisObj);
				mmSync.checkSyncComplete(thisObj);
			}
			
			&#x2F;&#x2F; FOR Debugging
			if (arguments != null) {
				&#x2F;&#x2F;logToConsole(JSON.stringify(arguments));
				
			}
		}
		
		&#x2F;&#x2F; Define error callback for cacheing of object to smartstore
		var cacheFail = function() {
			if (arguments != null) {
				logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt; Aruments for fail &quot; + JSON.stringify(arguments));
			}
		}
		
		&#x2F;&#x2F; Update the status screen. Increments by number of response.records recieved and 
		&#x2F;&#x2F; displays total size for objName
		mmSync.statusScreen.updateStatus(thisObj,response.records.length,response.totalSize);
		
		&#x2F;&#x2F;Cache result to local database&#x2F;soup
		mmSync.offlineQueue.cacheToLocal(thisObj,response.records, cacheSuccess, cacheFail);
		
		&#x2F;&#x2F;If query results are not complete, call nextUrl to retrieve more records
		if (response.done != true) {
			logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt; &quot; + thisObj + &quot; calling nextUrl&quot;);
			&#x2F;&#x2F;Query more
			mmSync.getNextUrl(response.nextRecordsUrl,mmSync.handleSyncObjectResult,thisObj,nocache);
		}
		
		
	}
	else {
		logToConsole(&quot;MMSync :: handleSyncObjectResult() =&gt; No results for query for &quot; + objName + &quot; &#x2F; &quot; + JSON.stringify(response) );
		mmSync.checkSyncComplete(objName);
	}	
}

&#x2F;**
 *  Gets the next url
 *  @method getNextUrl
 *  @param {String} nextRecordsUrl
 *  @param {Function} callback
 *  @param {Object} thisObj
 *  @param nocache
**&#x2F;
MMSync.prototype.getNextUrl = function(nextRecordsUrl,callback,thisObj,nocache) {
	var url = nextRecordsUrl;
	url =  url.replace(&#x27;services&#x2F;data&#x2F;&#x27;,&#x27;&#x27;);
	mmSync.forcetkClient.ajax(url,function (response) {
		callback(response,thisObj,nocache);
	},mmSync.handleErrorSFDC);
}

&#x2F;**
 * Check to see if all queryMore&#x27;s have been made for all objects in sync.json (compare length 
 * of mmSync.syncObjectCount to sync.json object array length
 * @method checkSyncComplete
 * @param {String} objName
 **&#x2F;
MMSync.prototype.checkSyncComplete = function(objName) {
	var mmSync = window.mmSync;
	&#x2F;&#x2F;update sync time in metadata soup
	var timeCallback = mmSync.checkSyncUpdateTimeCallback;
	
	logToConsole(&quot;MMSync :: checkSyncComplete() =&gt; Calling updateTime for: &quot; + objName);
	mmSync.offlineQueue.updateTimestamp(objName, mmSync.syncTime[objName], mmSync.objectsMetadata[objName],timeCallback);
	
}

&#x2F;**
 *  Check Sync Update Time Callback
 *  @method checkSyncUpdateTimeCallback
 *  @param result
**&#x2F;
MMSync.prototype.checkSyncUpdateTimeCallback = function(result) {
	var mmSync = window.mmSync;

	mmSync.objectsMetadata[result.name] = result;
	&#x2F;&#x2F;logToConsole(&quot;MMSync :: checkSyncComplete() :: timeCallback() =&gt; Time callback result time saved: &quot; + JSON.stringify(result));
	mmSync.syncObjectCount++;

	if (mmSync.syncObjectCount &gt;= mmSync.arraySyncObjects.length) {
		&#x2F;&#x2F;logToConsole(&quot;MMSync :: checkSyncComplete() :: timeCallback() =&gt; All items queried&quot;);
		mmSync.finishSync();
	}
	else {
		if (mmSync.useQueryCursorCount == true) {
			logToConsole(&quot;MMSync :: checkSyncUpdateTimeCallback() =&gt; useQueryCursorCount is true&quot;);
			if (mmSync.queryCursorCount &lt; mmSync.arraySyncObjects.length) {
				if (typeof mmSync.arraySyncObjects[mmSync.queryCursorCount] != &quot;undefined&quot;) {
					logToConsole(&quot;MMSync :: checkSyncUpdateTimeCallback() =&gt; calling syncObject for &quot; + mmSync.arraySyncObjects[mmSync.queryCursorCount].name);
					var so = mmSync.arraySyncObjects[mmSync.queryCursorCount];
					mmSync.syncObject(so);
				}
			}
			mmSync.queryCursorCount++;
		}
	}
}

&#x2F;**
 * Error handler for Salesforce data query
 * @method handleErrorSFDC
 * @param error
 **&#x2F;
MMSync.prototype.handleErrorSFDC = function(error) {
	logToConsole(&quot;onErrorSfdc: &quot; + JSON.stringify(error));
    alert(&#x27;Error getting sfdc data&#x27;);
    var err = new Error();
    err.logError(error);
}

&#x2F;**
 * Hide sync status screen and complete sync. 
 * Dispatch sync_complete event using jquery.trigger to alert application to continue.
 * @protected
 * @method finishSync
 **&#x2F;
MMSync.prototype.finishSync = function() {
	logToConsole(&quot;MMSync :: finishSync() =&gt;Finishing sync and removing status&quot;);
	var mmSync = window.mmSync;
	logToConsole(&quot;Unblocking UI&quot;);
	$j(mmSync).trigger(mmSync.SYNC_COMPLETE);
	$j.unblockUI();
	
}
&#x2F;**
 *  SObject VO
 *  @class SObject
 *  @constructor
**&#x2F;
function SObject () {
	this.dummyvar = null;
}

&#x2F;**
 *  @method start
**&#x2F;
SObject.prototype.start = function() {

};
&#x2F;**
 *  @class Util
 *  @constructor
**&#x2F;
function Util() {

}

&#x2F;**
 *  @method dateTimeToUTCString
 *  @param {DateTime} theDate
 *  @return {String}
**&#x2F;
Util.dateTimeToUTCString = function(theDate) {
    var today = theDate;
    var year = today.getUTCFullYear();
    var month = today.getUTCMonth() + 1;
    var day = today.getUTCDate();
    var hour = today.getUTCHours();
    var minute = today.getUTCMinutes();
    var second = today.getUTCSeconds();

    if (second &lt;= 9) {
        second = &quot;0&quot; + second;
    }

    if (month &lt;= 9) {
        month = &quot;0&quot; + month;
    }
    if (day &lt;= 9) {
        day = &quot;0&quot; + day;
    }
    if (hour &lt;= 9) {
        hour = &quot;0&quot; + hour;
    }
    if (minute &lt;= 9) {
        minute = &quot;0&quot; + minute;
    }

    return  year + &quot;-&quot; + month + &quot;-&quot; + day + &quot;T&quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second + &quot;Z&quot;;
};

&#x2F;**
 * @method LoadAllRecords
 * @param cursor
 * @param records
 * @deprecated -- use MMJSE_SmartStoreUtil.LoadAllRecords instead
 **&#x2F;
Util.LoadAllRecords = function(cursor,records){
  return MMJSE_SmartStoreUtil.LoadAllRecords(cursor,records);
}

&#x2F;**
 * @method AddEntriesFromCursorTo
 * param cursor
 * @param records
 * @deprecated -- use MMJSE_SmartStoreUtil.AddEntriesFromCursorTo instead
 **&#x2F;
Util.AddEntriesFromCursorTo = function(cursor,records) {
  return MMJSE_SmartStoreUtil.LoadAllRecords(cursor,records);
}
&#x2F;**
 *  @module MM_JSSyncEngine
 *  @class MMJSE_SmartStoreUtil
 *  @constructor
**&#x2F;
function MMJSE_SmartStoreUtil() {

}

&#x2F;**
 * load all records from all pages for the specified cursor into the specified array
 * @method LoadAllRecords
 * @static 
 * @param {cursor} cursor - 
 * @param {array} records -
 **&#x2F;
MMJSE_SmartStoreUtil.LoadAllRecords = function(cursor,records){
  console.log(&#x27;MMJSE_SmartStoreUtil.LoadAllRecords&#x27;);
  &#x2F;&#x2F;add the first page of results to records
  var that = this;
  records = MMJSE_SmartStoreUtil.AddEntriesFromCursorTo(cursor,records);
console.log(&quot;RECORDS&quot;);
  &#x2F;&#x2F;console.log(records);
  &#x2F;&#x2F;loop through available pages, populating records
  while(cursor.currentPageIndex &lt; cursor.totalPages - 1) {
    navigator.smartstore.moveCursorToNextPage(cursor, function(){
      records = MMJSE_SmartStoreUtil.AddEntriesFromCursorTo(cursor,records);
    });
  }
  return records;
}

&#x2F;**
 * load a limited set of records from the specified cursor into the specified array
 * @method LoadRecordsWithLimit 
 * @static 
 * @param limit
 * @param {cursor} cursor - 
 * @param {records} records - 
 **&#x2F;
MMJSE_SmartStoreUtil.LoadRecordsWithLimit = function(limit, cursor, records) {
  console.log(&#x27;MMJSE_SmartStoreUtil.LoadRecordsWithLimit&#x27;);
  &#x2F;&#x2F;add the first page of results to records
  var that = this;
  records = MMJSE_SmartStoreUtil.AddEntriesFromCursorTo(cursor,records);

  &#x2F;&#x2F;loop through available pages, populating records
	while(cursor.currentPageIndex &lt; cursor.totalPages - 1) {
		console.log(&#x27;Current Page is &#x27;+cursor.currentPageIndex+&#x27; and records length is &#x27;+records.length+&#x27;. Limit is &#x27;+limit);
		navigator.smartstore.moveCursorToNextPage(cursor, function(){
			records = MMJSE_SmartStoreUtil.AddEntriesFromCursorTo(cursor,records);
		});
		&#x2F;&#x2F;if we&#x27;ve exactly hit the limit, break the loop and let the method return
		if(records.length == limit)
		{
			break;
		}
		&#x2F;&#x2F;if we&#x27;ve gone over the limit, shrink down to the limit, break the loop, and let the method return
		if(records.length &gt; limit)
		{
			records = _.first(records,limit);
			break;
		}
	}
  	&#x2F;&#x2F;if we&#x27;ve gone over the limit (could happen if page size is larger than the limit, shrink and return)
	if(records.length &gt; limit)
	{
		records = _.first(records,limit);
	}

	return records;
}

&#x2F;**
 * define handler for paging from SmartStore query
 * @method AddEntriesFromCursorTo 
 * @static 
 * @param {cursor} cursor - the cursor to add items to
 * @param {array[]} records - the records to add
 **&#x2F;
MMJSE_SmartStoreUtil.AddEntriesFromCursorTo = function(cursor,records) {
  console.log(&#x27;MMJSE_SmartStoreUtil.AddEntriesFromCursorTo&#x27;);
  var curPageEntries = cursor.currentPageOrderedEntries;
  $j.each(curPageEntries, function(i,entry) {
    records.push(entry);
  });
  return records;
}



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
