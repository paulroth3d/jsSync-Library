<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;asynch.js - MM Sync Engine</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;mm-proth.s3.amazonaws.com&#x2F;syncIcon.png" title="MM Sync Engine"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Callback.html">Callback</a></li>
            
                <li><a href="..&#x2F;classes/CountdownCallback.html">CountdownCallback</a></li>
            
                <li><a href="..&#x2F;classes/CyclicalCallback.html">CyclicalCallback</a></li>
            
                <li><a href="..&#x2F;classes/EmptyCallback.html">EmptyCallback</a></li>
            
                <li><a href="..&#x2F;classes/NamedLatch.html">NamedLatch</a></li>
            
                <li><a href="..&#x2F;classes/RunnableCallback.html">RunnableCallback</a></li>
            
                <li><a href="..&#x2F;classes/SuccessFailCallback.html">SuccessFailCallback</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/JSAsynch.html">JSAsynch</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;asynch.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 *  Collection of asynchronous utils
*&#x2F;
&#x2F;*global Ext *&#x2F;

&#x2F;**
 *  Object that represents a specific method invocation that can be called at any time
 *  (or repeatedly) in an agnostic manner.
 *  @module JSAsynch
 *  @class Callback
 *  @constructor
 *  @param thisObj (Object) the scope object (commonly used for &#x27;this&#x27;) that the method will run in.
 *  @param fn (Function) the function to call
**&#x2F;
var Callback = function( thisObj, callbackFn ){
	
	this.init( thisObj, callbackFn );
	
	return( this );
};

&#x2F;**
 *  Describes the object as being a callback
 *  @for Callback
 *  @property isCallback
**&#x2F;
Callback.prototype.isCallback = true;

Callback.prototype.init = function( thisObj, callbackFn ){
	
	&#x2F;&#x2F;if( thisObj &amp;&amp; thisObj.thisObj &amp;&amp; thisObj.callbackFn ){
	
	&#x2F;&#x2F;-- use instanceof to determine how to importa instead of using hasProperty etc
	if( thisObj instanceof Callback ){
		&#x2F;&#x2F;-- assume it is a callback
		this.thisObj = thisObj.thisObj;
		this.callbackFn = thisObj.callbackFn;
	} else {
		this.thisObj = thisObj;
		this.callbackFn = callbackFn;
	}
};

&#x2F;**
 * Empty method to provide a NOOP
 * @method empty
 * @protected
 **&#x2F;
Callback.prototype.empty = function(){};

&#x2F;**
 *  Performs the callback.
 *  &lt;p&gt;Note, exec, callback, run, among other names could potentially be considered keywoards,
 *  so the name was chosen instead&lt;&#x2F;p&gt;
 *  &lt;p&gt;Calling the method with a null scope can cause some unexpected consequences&lt;&#x2F;p&gt;
 *  @method execCallback
 *  @param [PASSTHROUGH]
**&#x2F;
Callback.prototype.execCallback = function(){
	&#x2F;&#x2F;alert( &#x27;callback was requested&#x27; );
	
	if( this.callbackFn ){
		this.callbackFn.apply( this.thisObj, arguments );
	}
};

&#x2F;*
var cb = new Callback( this,
	function( noun, verb ){
		console.log( &quot;a &quot; + noun + &quot; has &quot; + verb + &quot;ed&quot; );
	}
);

cb.execCallback( &quot;cat&quot;, &quot;jump&quot; );
*&#x2F;

&#x2F;**
 *  Empty callback if a callback must exist but not do anything.
 *  @module JSAsynch
 *  @class EmptyCallback
**&#x2F;
var EmptyCallback = function(){
	var emptyFn = function(){};
	this.init( this, emptyFn );
	
	return( this );
};
EmptyCallback.prototype = new Callback();
EmptyCallback.prototype.constructor = EmptyCallback;

&#x2F;&#x2F;-	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	

&#x2F;**
 *  Object that supports both a success and a failure
 *  @class SuccessFailCallback
 *  @constructor
 *  @extends Callback
 *  @param {Object} successThis
 *  @param {Function} succcessFn
 *  @param {Object} failureThis
 *  @param {Function} failureFn
**&#x2F;
var SuccessFailCallback = function( successThis, successFn, failureThis, failureFn ){
	this.successCB = new Callback( successThis, successFn );
	this.failureCB = new Callback( failureThis, failureFn );
};

SuccessFailCallback.prototype.isCallback = true;

&#x2F;**
 *  Calls success method.
 *  (Meaning it calls the successFn using successThis as the scope
 *  @method success
 *  @for SuccessFailCallback
 *  @param [PASSTHROUGH]
**&#x2F;
SuccessFailCallback.prototype.success = function(){
	this.successCB.execCallback.apply( this.successCB, arguments );
};

&#x2F;**
 *  Calls failure method.
 *  (Meaning it calls the failureFn using failureThis as the scope
 *  @method fail
 *  @for SuccessFailCallback
 *  @param [PASSTHROUGH]
**&#x2F;
SuccessFailCallback.prototype.fail = function(){
	this.failureCB.execCallback.apply( this.failureCB, arguments );
};

var emptySFCallback = new SuccessFailCallback( this, function(){}, this, function(){} );

&#x2F;**
 *  Determines whether the object is a successFailCallback
 *  @global
 *  @method isSuccessFailCallback
 *  @param {Object} obj - object to be determined whether it is a successFailCallback
**&#x2F;
var isSuccessFailCallback = function( obj ){
	return( obj &amp;&amp; obj.success &amp;&amp; obj.fail );
}

&#x2F;&#x2F;-- sample success fail callbacks
&#x2F;**
 *  simple function that claims sucess and console logs out all arguments.
 *  &lt;p&gt;Example usage: forcetkClient.query( myQuery, simpleSuccess, simpleFailure );&lt;&#x2F;p&gt;
 *  @global
 *  @method simpleSuccess
 *  @param [PASSTHROUGH]
**&#x2F;
function simpleSuccess( successObj ){
	logMsg( &quot;success&quot; );
	printArguments( arguments );
}

&#x2F;**
 *  Simple function that claims failure and console logs out all arguments
 *  &lt;p&gt;Example usage: forcetkClient.query( myQuery, simpleSuccess, simpleFailure );&lt;&#x2F;p&gt;
 *  @global
 *  @method simpleFailure
 *  @param [PASSTHROUGH]
**&#x2F;
function simpleFailure( failObj ){
	logMsg( &quot;fail&quot; );
	printArguments( arguments );
}

&#x2F;**
 *  Simple callback that simply claims success, or failure and console logs the results.
 *  &lt;p&gt;Note: it may be preferrable to use a different object with large datasets&#x2F;volumes
 *  as consolelog, especially from the device can have issues with too many records being printed at a time&lt;&#x2F;p&gt;
 *  @property debugCB
 *  @global
**&#x2F;
var debugCB = new SuccessFailCallback( this, simpleSuccess, this, simpleFailure );

&#x2F;*
var successFailure = new SuccessFailCallback(
this, function( noun, verb ){
	debugger;
	console.log( &quot;a &quot; + noun + &quot; &quot; + verb + &quot;ed&quot; );
},
this, function( noun, verb ){
	debugger;
	console.log( &quot;a &quot; + noun + &quot; failed to &quot; + verb );
});

&#x2F;&#x2F;-- inline test
&#x2F;&#x2F;successFailure.success( &quot;dog&quot;, &quot;jumped&quot; );
&#x2F;&#x2F;successFailure.fail( &quot;programmer&quot;, &quot;sleep &quot; );


&#x2F;&#x2F;-	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	

&#x2F;**
 *  Object that has a set number of latches. Once all the latches are released
 *  @class CountdownCallback
 *  @constructor
 *  @param {int} latchCount
 *  @param {Object} thisObj
 *  @param {Function} callbackFn
 *  @extends Callback
**&#x2F;
var CountdownCallback = function( latchCount, thisObj, callbackFn ){
	this.latchCount = latchCount;
	
	&#x2F;&#x2F;Callback.apply( this, thisObj, callbackFn );
	this.init( thisObj, callbackFn );
	
	return( this );
};

CountdownCallback.prototype = new Callback();
CountdownCallback.prototype.constructor = CountdownCallback;

&#x2F;**
 *  Adds a latch to the count as something else that needs to be waited for
 *  @method addStrap
 *  @for CountdownCallback
**&#x2F;
CountdownCallback.prototype.addStrap = function(){
	this.latchCount++;
	console.log( &quot;addStrap[&quot; + this.latchCount + &quot;]&quot; );
};

&#x2F;**
 *  Determines the number of latches remaining
 *  @method getLatchCount
**&#x2F;
CountdownCallback.prototype.getLatchCount = function(){
	return( this.latchCount );
};

&#x2F;**
 *  Determines if the latch is currently released
 *  @method isReleased
**&#x2F;
CountdownCallback.prototype.isReleased = function(){
	return( this.latchCount &lt;= 0 );
};

&#x2F;**
 *  Releases a latch and executes the callbackFn if all the latches are released.
 *  @param boolean - whether the latch is currently released
 *  @method release
 *  @param [PASSTHROUGH]
**&#x2F;
CountdownCallback.prototype.release = function(){
	this.latchCount--;
	
	console.log( &quot;release[&quot; + this.latchCount + &quot;]&quot; );
	
	if( this.latchCount &lt; 0 ){ this.latchCount = 0; }
	
	if( this.latchCount === 0 ){
		this.callbackFn.apply( this.thisObj, arguments );
		return( true );
	} else {
		return( false );
	}
};

&#x2F;*
var ccb = new CountdownCallback( 2, this,
	function( noun, verb ){
		console.log( &quot;a &quot; + noun + &quot; has &quot; + verb + &quot;ed&quot; );
	}
);
console.log( &quot;is callback: &quot; + ( ccb instanceof Callback ) );
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() );
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() ); &#x2F;&#x2F;-- released
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() ); &#x2F;&#x2F;-- still released
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
*&#x2F;

&#x2F;&#x2F;- #	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	

&#x2F;**
 * NamedLatch requires that all latches provided must be released
 * This means that latches must be unique or will throw an exception.
 * @class NamedLatch
 * @constructor
 * @extends CountdownCallback
 * @param latchList (Array&lt;String&gt;)
 * @param thisObj
 * @param callbackFn
 **&#x2F;
var NamedLatch = function( latchList, thisObj, callbackFn ){
	this.latches = {};
	
	this.isChatty = false;
	
	if( latchList ){
		for( var i = 0; i &lt; latchList.length; i++ ){
			this.addStrap( latchList[i] );
		}
	}
	
	this.init( thisObj, callbackFn );
};

var NamedLatchLock = function( latchName ){
	this.name = latchName;
};

NamedLatch.prototype = new Callback();
NamedLatch.prototype.constructor = NamedLatch;

NamedLatch.prototype.addStrap = function( latchName ){
	
	if( !latchName ){
		return;
	}
	
	&#x2F;&#x2F;-- either the latches are constant to add, but harder to tell if all are done
	&#x2F;&#x2F;-- or are harder to add and easier to tell if all are done
	
	if( this.latches.hasOwnProperty( latchName )){
		if( console &amp;&amp; console.error ){
			console.error( &quot;Latch[&quot; + latchName + &quot;] has already been used&quot; );
		}
		
		throw( &quot;ALREADY_USED&quot; );
	} else {
		this.latches[ latchName ] = new NamedLatchLock( latchName );
	}
};

NamedLatch.prototype.getLatchCount = function(){
	var result = 0;
	var aLatch = null;
	for( var i in this.latches ){
		aLatch = this.latches[i];
		if( aLatch instanceof NamedLatchLock &amp;&amp; !aLatch.isReleased ){
			result++;
		}
	}
	
	return( result );
};

NamedLatch.prototype.isReleased = function(){
	
	var newLatch = null;
	for( var i in this.latches ){
		newLatch = this.latches[i];
		
		&#x2F;&#x2F; assert the namedLatchLock
		if( newLatch instanceof NamedLatchLock ){
			if( !newLatch.isReleased ){
				return( false );
			}
		}
	}
	
	return( true );
};

NamedLatch.prototype.hasLatch = function( latchName ){
	if( !latchName ){
		return;
	}
	
	return( this.latches.hasOwnProperty( latchName ));
};

&#x2F;**
 *  Determines whether a named latch has been released
 *  @method isLatchReleased
 *  @param {String} latchName
**&#x2F;
NamedLatch.prototype.isLatchReleased = function( latchName ){
	if( !latchName ){
		return;
	}
	
	if( this.latches.hasOwnProperty( latchName ) ){
		var myLatch = this.latches[ latchName ];
		return( myLatch.isReleased );
	} else {
		return( true );
	}
};

NamedLatch.prototype.release = function( latchName, callbackArguments ){
	if( !latchName ){
		return;
	}
	
	if( !this.latches.hasOwnProperty( latchName )){
		if( console &amp;&amp; console.error ){
			console.error( &quot;no latch was found with that name[&quot; + latchName + &quot;]&quot; );
		}
		
		throw( &quot;NOT_FOUND&quot; );
	} else {
		var myLatch = this.latches[ latchName ];
		var wasAlreadyReleased = myLatch.isReleased;
		
		if( this.isChatty &amp;&amp; console &amp;&amp; console.log ){
			console.log( &quot;released latch[&quot; + latchName + &quot;]&quot; );
		}
		
		myLatch.isReleased = true;
		
		if( this.isReleased() ){
			this.callbackFn.apply( this.thisObj, callbackArguments );
		}
		
		return( !wasAlreadyReleased );
	}
	
	return( false );
};

&#x2F;*
debugger;
var myNamedLatch = new NamedLatch( [&quot;PhoneGap&quot;,&quot;Sencha&quot;,&quot;JQuery&quot;], this, function( noun, verb ){
	console.log( &quot;The &quot; + noun + &quot; just &quot; + verb + &quot;ed&quot; );
});

myNamedLatch.release( &quot;PhoneGap&quot;, [&quot;dog&quot;, &quot;jump&quot;] );
myNamedLatch.release( &quot;Sencha&quot;, [&quot;dog&quot;, &quot;jump&quot;] );
myNamedLatch.release( &quot;JQuery&quot;, [&quot;dog&quot;, &quot;jump&quot;] );
*&#x2F;

&#x2F;&#x2F;-	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	#	
&#x2F;**
 *  Object that represents a cyclical barrier
 *  @class CyclicalCallback
 *  @constructor
 *  @extends CountdownCallback
 *  @param {int} latchCount
 *  @param {Object} thisObj
 *  @param {Function} callbackFn
**&#x2F;
var CyclicalCallback = function( latchCount, thisObj, callbackFn ){
	this.latchCount = latchCount;
	
	this.initialLatch = latchCount;
	
	&#x2F;&#x2F;Callback.apply( this, thisObj, callbackFn );
	this.init( thisObj, callbackFn );
};

CyclicalCallback.prototype = new CountdownCallback();
CyclicalCallback.prototype.constructor = CyclicalCallback;

CyclicalCallback.prototype.release = function(){
	if( CountdownCallback.prototype.release.apply( this, arguments ) ){
		this.latchCount = this.initialLatch;
		return( true );
	} else {
		return( false );
	}
};

&#x2F;*
ccb = new CyclicalCallback( 2, this, function( noun, verb ){
	console.log( &#x27;a &#x27; + noun + &#x27; &#x27; + verb + &#x27;ed&#x27; );
});
console.log( &quot;is callback: &quot; + ( ccb instanceof Callback ) );
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() );
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() ); &#x2F;&#x2F;-- released
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() );
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
console.log( &#x27;latch:&#x27; + ccb.getLatchCount() ); &#x2F;&#x2F;-- released
ccb.release(&#x27;dog&#x27;,&#x27;jump&#x27;);
*&#x2F;

&#x2F;**
 *  Abstract class that contains a callback that should execute at some point after
 *  completing run. (This allows for asynchronous methods to run that should perform
 *  a callback when it has completed)
 *  @class RunnableCallback
 *  @constructor
**&#x2F;
var RunnableCallback = function( callback ){
	this.callback = callback;
};

RunnableCallback.prototype.isCallback = true;

&#x2F;**
 *  Calls the callback
 *  @method run
 *  @param [PASSTHROUGH]
**&#x2F;
RunnableCallback.prototype.run = function(){
	&#x2F;&#x2F;-- provide additional logic if needed
	this.callback.execCallback.apply( this, arguments );
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
